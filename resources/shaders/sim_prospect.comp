#version 450 core

#define MAX_GEO_PER_AIR 3

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// Types -----------------------------------------------------------------------

struct Result {
    vec4 lift;
    vec4 drag;
    vec4 torq;
};

struct GeoPixel {
    vec2 windPos;
    ivec2 texCoord;
    vec4 normal;
};

struct AirPixel {
    vec2 windPos;
    vec2 backforce;
    vec4 velocity; // fourth component is turbulence
};

struct AirGeoMapElement {
    int geoCount;
    int geoIndices[MAX_GEO_PER_AIR];
};

// Constants -------------------------------------------------------------------

// Uniforms --------------------------------------------------------------------

layout (binding = 0, rgba8) uniform image2D u_fboImg;
layout (binding = 2, rgba16_snorm) uniform image2D u_fboNormImg;

// Uniform buffer for better read-only performance
layout (binding = 0, std140) uniform Constants {
    int u_maxGeoPixels;
    int u_maxAirPixels;
    int u_screenSize;
    float u_windframeSize;
    float u_sliceSize;
    float u_windSpeed;
    float u_dt;
    int u_slice;
    float u_sliceZ;
    uint u_debug;
};

layout (binding = 0, std430) restrict buffer GeoPixels {
    coherent int u_geoCount;
    int u_GeoPixels_pad0;
    int u_GeoPixels_pad1;
    int u_GeoPixels_pad2;
    GeoPixel u_geoPixels[];
};

layout (binding = 1, std430) restrict buffer AirPixels {
    int u_airCount;
    int u_AirPixels_pad0;
    int u_AirPixels_pad1;
    int u_AirPixels_pad2;
    AirPixel u_airPixels[];
};

layout (binding = 2, std430) restrict buffer PrevAirPixels {
    int u_prevAirCount;
    int u_PrevAirPixels_pad0;
    int u_PrevAirPixels_pad1;
    int u_PrevAirPixels_pad2;
    AirPixel u_prevAirPixels[];
};

layout (binding = 3, std430) restrict buffer AirGeoMap {
    AirGeoMapElement u_airGeoMap[];
};

layout (binding = 4, std430) restrict buffer Results {
    Result u_results[];
};


// Functions -------------------------------------------------------------------

vec2 screenToWind(vec2 screen) {
    return (screen / u_screenSize - 0.5f) * u_windframeSize;
}

ivec2 getPixelDelta(vec2 dir) {
    vec2 signs = sign(dir);
    vec2 mags = dir * signs;
    if (mags.y >= mags.x) {
        return ivec2(0, int(signs.y));
    }
    else {
        return ivec2(int(signs.x), 0);
    }
}

void main() {
    ivec2 texCoord = ivec2(gl_GlobalInvocationID.xy);
    if (texCoord.x >= u_screenSize || texCoord.y >= u_screenSize) {
        return;
    }

    vec4 color = imageLoad(u_fboImg, texCoord);
    if (color.r == 0.0f) {
        return;
    }

    imageStore(u_fboImg, texCoord, vec4(color.r, 0.0f, 0.0f, 0.0f));

    vec2 geoWindPos = screenToWind(vec2(texCoord) + color.gb);
    vec3 geoNormal = imageLoad(u_fboNormImg, texCoord).xyz;

    ivec2 nextTexCoord = texCoord + getPixelDelta(geoNormal.xy);
    vec4 nextColor = imageLoad(u_fboImg, nextTexCoord);
    if (nextColor.r != 0.0f) {
        return;
    }

    int geoI = atomicAdd(u_geoCount, 1);
    if (geoI >= u_maxGeoPixels) {
        return;
    }

    u_geoPixels[geoI].windPos = geoWindPos.xy;
    u_geoPixels[geoI].normal = vec4(geoNormal, 0.0f);
    u_geoPixels[geoI].texCoord = texCoord;
}