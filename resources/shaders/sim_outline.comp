#version 450 core

#define MAX_GEO_PER_AIR 3

layout (local_size_x = 1024, local_size_y = 1, local_size_z = 1) in;

// Types -----------------------------------------------------------------------

struct GeoPixel {
    vec2 windPos;
    ivec2 texCoord;
    vec4 normal;
};

struct AirPixel {
    vec2 windPos;
    vec2 backforce;
    vec4 velocity;
};

struct AirGeoMapElement {
    int geoCount;
    int geoIndices[MAX_GEO_PER_AIR];
};

// Constants -------------------------------------------------------------------

const float k_maxSearchDist = 0.2f; // In wind space
const float k_turbulenceDist = 0.1f;

const float k_minNormalZ = 1.0f / 1000000.0f;
const float k_maxNormalZ = 1.0f - k_minNormalZ;

const bool k_doLineSearch = true;

const bool k_distinguishActivePixels = true; // Makes certain "active" pixels brigher for visual clarity, but lowers performance
const float k_inactiveVal = k_distinguishActivePixels ? 1.0f / 3.0f : 1.0f;

const bool k_ignoreEdges = false;

// Uniforms --------------------------------------------------------------------

layout (binding = 0, rgba8) uniform image2D u_fboImg;
layout (binding = 3, r32i) uniform iimage2D u_flagImg;
layout (binding = 4, rgba8) uniform image2D u_sideImg;

// Uniform buffer for better read-only performance
layout (binding = 0, std140) uniform Constants {
    int u_swap;
    int u_maxGeoPixels;
    int u_maxAirPixels;
    int u_screenSize;
    float u_windframeSize;
    float u_sliceSize;
    float u_windSpeed;
    float u_dt;
    float u_momentOfInertia;
    int u_slice;
    float u_sliceZ;
    uint u_debug;
};

layout (binding = 0, std430) restrict buffer Mutables {
    int u_padding0;
    int u_geoCount;
    coherent int u_airCount[2];
    vec4 u_lift;
    vec4 u_drag;
    vec4 u_torque;
};

layout (binding = 1, std430) restrict buffer GeoPixels {
    GeoPixel u_geoPixels[];
};
layout (binding = 2, std430) restrict buffer AirPixels {
    AirPixel u_airPixels[];
};
layout (binding = 3, std430) restrict buffer AirGeoMap {
    coherent AirGeoMapElement u_airGeoMap[]; // TODO: does this need to be coherent?
};

// Functions -------------------------------------------------------------------

vec2 windToScreen(vec2 wind) {
    return (wind / u_windframeSize + 0.5f) * float(u_screenSize);
}

float screenToWindDist(float screenDist) {
    return screenDist / float(u_screenSize) * u_windframeSize;
}

void main() {
    int workI = int(gl_LocalInvocationID.x);

    for (int geoI = workI; geoI < u_geoCount; geoI += int(gl_WorkGroupSize.x)) {

        vec2 geoWindPos = u_geoPixels[geoI].windPos;
        vec3 geoNormal = u_geoPixels[geoI].normal.xyz;
        ivec2 geoTexCoord = u_geoPixels[geoI].texCoord; // Need exact texture coord because rasterization math and our wind-to-screen math don't always align

        bool shouldSpawn = geoNormal.z >= k_minNormalZ && geoNormal.z <= k_maxNormalZ;

        // Look for existing air pixel
        vec2 screenPos = vec2(geoTexCoord) + 0.5f;
        ivec2 pixel = ivec2(screenPos);
        vec2 screenDir = normalize(geoNormal.xy);
        vec2 corner; if (k_doLineSearch) corner = step(vec2(0.0f), screenDir);
        float totalDist = 0.0f;
        while (true) {            
            if (k_doLineSearch) {
                // TODO: optimize
                vec2 delta = corner - (screenPos - vec2(pixel));
                vec2 dist = abs(delta / screenDir);
                if (dist.x < dist.y) {
                    screenPos += screenDir * dist.x;
                    pixel.x += int(sign(screenDir.x));
                    totalDist += screenToWindDist(dist.x);
                }
                else {
                    screenPos += screenDir * dist.y;
                    pixel.y += int(sign(screenDir.y));
                    totalDist += screenToWindDist(dist.y);
                }
            }
            else {
                screenPos += screenDir;
                pixel = ivec2(screenPos);
                totalDist += screenToWindDist(1.0f);
            }

            if (totalDist > k_maxSearchDist) {
                break;
            }

            vec4 color = imageLoad(u_fboImg, pixel);

            // Visualize the search
            if (bool(u_debug)) {
                //imageStore(u_fboImg, pixel, vec4(color.r, color.g, 0.5f, color.a));
            }

            if (color.r != 0.0f) { // we found a geo pixel
                break;
            }
            if (color.g != 0.0f) { // we found an air pixel
                int airI = imageLoad(u_flagImg, pixel).x;               
                if (airI != 0) { // TODO: this should not be necessary, just here for sanity
                    --airI;

                    int mapI = atomicAdd(u_airGeoMap[airI].geoCount, 1);
                    if (mapI >= MAX_GEO_PER_AIR) {
                        break;
                    }
                    u_airGeoMap[airI].geoIndices[mapI] = geoI;

                    shouldSpawn = false;   
                    break;
                }
            }
        }

        // Overwrite flag image with geometry index
        imageStore(u_flagImg, geoTexCoord, ivec4(geoI + 1, 0, 0, 0));
    
        // Make a new air pixel
        if (shouldSpawn) {
            int airI = atomicAdd(u_airCount[u_swap], 1);
            if (airI >= u_maxAirPixels) {
                continue;
            }

            u_airGeoMap[airI].geoCount = 1;
            u_airGeoMap[airI].geoIndices[0] = geoI;

            vec2 airWindPos = geoWindPos;
            vec3 refl = reflect(vec3(0.0f, 0.0f, -1.0f), geoNormal);
            vec3 airVelocity = refl * u_windSpeed;

            u_airPixels[airI + u_swap * u_maxAirPixels].windPos = airWindPos;
            u_airPixels[airI + u_swap * u_maxAirPixels].velocity = vec4(airVelocity, 0.0f);
            u_airPixels[airI + u_swap * u_maxAirPixels].backforce = vec2(0.0f);

            // Draw to fbo to avoid another draw later, only necessary for seeing the results immediately
            if (bool(u_debug)) {
                vec4 color = imageLoad(u_fboImg, geoTexCoord);
                color.g = k_inactiveVal;
                imageStore(u_fboImg, geoTexCoord, color);
            }
        }

        // Color active geo pixels more brightly
        if (bool(u_debug) && k_distinguishActivePixels) {
            vec4 color = imageLoad(u_fboImg, geoTexCoord);
            color.r = 1.0f;
            imageStore(u_fboImg, geoTexCoord, color);

            if (!k_ignoreEdges || abs(geoWindPos.x) <= 0.5f) {
                ivec2 sideTexCoord = ivec2(windToScreen(vec2(u_sliceZ, geoWindPos.y)));
                sideTexCoord.y = geoTexCoord.y;
                color = imageLoad(u_sideImg, sideTexCoord);
                color.r = 1.0f;
                imageStore(u_sideImg, sideTexCoord, color);
            }
        }
    }
}