#version 450 core

#define MAX_GEO_PER_AIR 3



layout (local_size_x = 1024, local_size_y = 1, local_size_z = 1) in;

// Types -----------------------------------------------------------------------

struct GeoPixel {
    vec4 worldPos;
    vec4 normal;
    ivec4 texCoord;
};

struct AirPixel {
    vec4 worldPos;
    vec4 velocity;
    vec4 backForce;
};

struct AirGeoMapElement {
    int geoCount;
    int geoIndices[MAX_GEO_PER_AIR];
};

// Constants -------------------------------------------------------------------

const bool k_distinguishActivePixels = true; // Makes certain "active" pixels brigher for visual clarity, but lowers performance
const float k_inactiveVal = k_distinguishActivePixels ? 1.0f / 3.0f : 1.0f;

const bool k_ignoreEdges = false;

// Uniforms --------------------------------------------------------------------

layout (binding = 0, rgba8) uniform image2D u_fboImg;
layout (binding = 3, r32i) uniform iimage2D u_flagImg;
layout (binding = 4, rgba8) uniform image2D u_sideImg;

layout (binding = 0, std430) restrict buffer SSBO {
    int u_swap;
    int u_geoCount;
    int u_airCount[2];
    int u_maxGeoPixels;
    int u_maxAirPixels;
    int u_screenSize;
    int u_padding0;
    float u_sliceSize;
    float u_windSpeed;
    float u_dt;
    uint u_debug;
    vec4 u_lift;
    vec4 u_drag;
};

// Done this way because having a lot of large static sized arrays makes shader compilation super slow for some reason
layout (binding = 1, std430) buffer GeoPixels { // TODO: should be restrict?
    GeoPixel u_geoPixels[];
};
layout (binding = 2, std430) buffer AirPixels { // TODO: should be restrict?
    AirPixel u_airPixels[];
};
layout (binding = 3, std430) buffer AirGeoMap { // TODO: should be restrict?
    AirGeoMapElement u_airGeoMap[];
};

// Functions -------------------------------------------------------------------

vec2 worldToScreen(vec2 world) {
    return (world * 0.5f + 0.5f) * float(u_screenSize);
}

void main() {
    int workI = int(gl_LocalInvocationID.x);
    int counterSwap = 1 - u_swap;

    for (int prevAirI = workI; prevAirI < u_airCount[counterSwap]; prevAirI += int(gl_WorkGroupSize.x)) {

        vec3 worldPos = u_airPixels[prevAirI + counterSwap * u_maxAirPixels].worldPos.xyz;
        float turbulence = u_airPixels[prevAirI + counterSwap * u_maxAirPixels].worldPos.w;
        
        ivec2 texCoord = ivec2(worldToScreen(worldPos.xy));
        ivec2 sideTexCoord; if (bool(u_debug)) sideTexCoord = ivec2(worldToScreen(vec2(-worldPos.z - 1.0f, worldPos.y)));

        // Check if in texture
        if (texCoord.x < 0 || texCoord.y < 0 || texCoord.x >= u_screenSize || texCoord.y >= u_screenSize) {
            continue;
        }
        // Check if in geometry
        vec4 color = imageLoad(u_fboImg, texCoord);
        if (color.r != 0.0f) {
            continue;
        }
        
        // Move to current air pixel buffer
        int airI = atomicAdd(u_airCount[u_swap], 1);
        if (airI >= u_maxAirPixels) {
            return;
        }
        u_airPixels[airI + u_swap * u_maxAirPixels] = u_airPixels[prevAirI + counterSwap * u_maxAirPixels];
        u_airGeoMap[airI].geoCount = 0; // This air pixel is not yet associated with any geometry

        // Store air index
        imageStore(u_flagImg, texCoord, ivec4(airI + 1, 0, 0, 0));
        
        // Draw to front view
        color.g = k_inactiveVal;
        color.b = turbulence;
        imageStore(u_fboImg, texCoord, color);

        // Draw to side view
        if (bool(u_debug) && (!k_ignoreEdges || abs(worldPos.x) <= 0.5f)) {
            color = imageLoad(u_sideImg, sideTexCoord);
            color.g = k_inactiveVal;
            color.b = turbulence;
            imageStore(u_sideImg, sideTexCoord, color);
        }
    }        
}