#version 450 core

#ifndef WORK_GROUP_SIZE
#define WORK_GROUP_SIZE 1024
#endif

#ifndef WORK_GROUP_SIZE_2D
#define WORK_GROUP_SIZE_2D ivec2(32, 32)
#endif

layout (local_size_x = WORK_GROUP_SIZE, local_size_y = 1, local_size_z = 1) in;

// Types -----------------------------------------------------------------------

struct Particle {
    vec3 position;
    float mass;
    vec3 normal;
    float padding0;
    vec3 force;
    float padding1;
    vec3 prevPosition;
    float padding2;
};

// Constants -------------------------------------------------------------------

const int k_workGroupSize = WORK_GROUP_SIZE;
const ivec2 k_workGroupSize2D = WORK_GROUP_SIZE_2D;
const float k_pi = 3.14159265f;
const float k_sqrt2 = 1.41421356f;
const float k_damping = 0.01f;
const int k_constrainPasses = 16;
const bool k_doSphere = true;
const float k_sphereRadius = 0.4f;
const float k_sphereRadius2 = k_sphereRadius * k_sphereRadius;
const vec3 k_sphereStartP = vec3(0.0f, -0.25f, 1.0f);
const vec3 k_sphereEndP = vec3(0.0f, -0.25f, -1.0f);

// Uniforms --------------------------------------------------------------------

uniform ivec2 u_particleCounts;
uniform ivec2 u_clothLOD;
uniform float u_weaveSize;
uniform float u_dt;
uniform vec3 u_gravity;
uniform float u_time;

layout (binding = 0, std430) restrict buffer Particles {
    Particle u_particles[];
};

// Shared ----------------------------------------------------------------------

// Functions -------------------------------------------------------------------

float dist2(vec3 p1, vec3 p2) {
    vec3 d = p1 - p2;
    return dot(d, d);
}

float isInBounds(ivec2 p) {
    vec2 s = step(ivec2(0), p) - step(u_particleCounts, p);
    return s.x * s.y;
}

vec3 getPosition(int pI) {
    return u_particles[pI].position;
}

void setPosition(int pI, vec3 pos) {
    u_particles[pI].position = pos;
}

vec3 getPosition(ivec2 p) {
    return getPosition(p.y * u_particleCounts.x + p.x);
}

void setPosition(ivec2 p, vec3 pos) {
    setPosition(p.y * u_particleCounts.x + p.x, pos);
}

void constrain(int pI1, int pI2, float restDist) {
    vec3 d = getPosition(pI2) - getPosition(pI1);
    float dist = length(d);
    vec3 correction = 0.5f * d * (1.0f - restDist / dist);
    if (u_particles[pI1].mass > 0.0f) u_particles[pI1].position += correction;
    if (u_particles[pI2].mass > 0.0f) u_particles[pI2].position -= correction;
}

void update(int pI) {
    Particle particle = u_particles[pI];
    vec3 pos = particle.position;
    if (particle.mass > 0.0f) {
        vec3 acceleration = particle.force / particle.mass + u_gravity;
        particle.position += (pos - particle.prevPosition) * (1.0f - k_damping) + acceleration * u_dt * u_dt;
    }
    particle.prevPosition = pos;
    particle.force = vec3(0.0f);
    u_particles[pI] = particle;
}

void calcNormal(ivec2 p) {
    int pI = p.y * u_particleCounts.x + p.x;
    vec3 pos = getPosition(pI);
    ivec2 ptr = min(p + 1, u_clothLOD);
    ivec2 pbl = max(p - 1, ivec2(0));
    vec3 dpx = getPosition(ivec2(ptr.x, p.y)) - pos;
    vec3 dpy = getPosition(ivec2(p.x, ptr.y)) - pos;
    vec3 dnx = getPosition(ivec2(pbl.x, p.y)) - pos;
    vec3 dny = getPosition(ivec2(p.x, pbl.y)) - pos;
    u_particles[pI].normal = normalize(cross(dpx, dpy) + cross(dpy, dnx) + cross(dnx, dny) + cross(dny, dpx));
}

void main() {
    const int workI = int(gl_LocalInvocationIndex);
    const ivec2 workI2D = ivec2(workI % k_workGroupSize2D.x, workI / k_workGroupSize2D.x);
    const bool isThread2D = all(lessThan(workI2D, k_workGroupSize2D)); // 2D workgroup area may be slightly smaller than the 1D workgroup size
    const int k_particleCount = u_particleCounts.x * u_particleCounts.y;

    if (k_doSphere) {
        vec3 sphereOrigin = mix(k_sphereStartP, k_sphereEndP, u_time);
        for (int pI = workI; pI < k_particleCount; pI += k_workGroupSize) {
            vec3 pos = getPosition(pI);
            vec3 d = pos - sphereOrigin;
            float dist2 = dot(d, d);
            if (dist2 < k_sphereRadius2) {
                setPosition(pI, sphereOrigin + d / sqrt(dist2) * k_sphereRadius);
            }
        }
    }
    else {
        for (int pI = workI; pI < k_particleCount; pI += k_workGroupSize) {
            vec3 position = u_particles[pI].position.xyz;
            u_particles[pI].position.z = sin(u_time * 2.0f * k_pi + position.x * position.y * 100.0f) * 0.025f;
        }
    }

    barrier();

    // Constrain
    // TODO: make constaints pass independent
    if (isThread2D) {
        float w0 = u_weaveSize;
        float w1 = w0 * k_sqrt2;
        float w2 = w0 * 2.0f;
        float w3 = w2 * k_sqrt2;
        for (int pass = 0; pass < k_constrainPasses; ++pass) {
            for (ivec2 p = ivec2(0, workI2D.y); p.y < u_particleCounts.y; p.y += k_workGroupSize2D.y) {
                for (p.x = workI2D.x; p.x < u_particleCounts.x - 1; p.x += k_workGroupSize2D.x) {
                    int pI = p.y * u_particleCounts.x + p.x;
                    constrain(pI, pI + 1, w0);
                }
            }
            for (ivec2 p = ivec2(0, workI2D.y); p.y < u_particleCounts.y - 1; p.y += k_workGroupSize2D.y) {
                for (p.x = workI2D.x; p.x < u_particleCounts.x; p.x += k_workGroupSize2D.x) {
                    int pI = p.y * u_particleCounts.x + p.x;
                    constrain(pI, pI + u_particleCounts.x, w0);
                }
            }
            for (ivec2 p = ivec2(0, workI2D.y); p.y < u_particleCounts.y - 1; p.y += k_workGroupSize2D.y) {
                for (p.x = workI2D.x; p.x < u_particleCounts.x - 1; p.x += k_workGroupSize2D.x) {
                    int pI = p.y * u_particleCounts.x + p.x;
                    constrain(pI, pI + u_particleCounts.x + 1, w1);
                    constrain(pI + 1, pI + u_particleCounts.x, w1);
                }
            }
            for (ivec2 p = ivec2(0, workI2D.y); p.y < u_particleCounts.y; p.y += k_workGroupSize2D.y) {
                for (p.x = workI2D.x; p.x < u_particleCounts.x - 2; p.x += k_workGroupSize2D.x) {
                    int pI = p.y * u_particleCounts.x + p.x;
                    constrain(pI, pI + 2, w2);
                }
            }
            for (ivec2 p = ivec2(0, workI2D.y); p.y < u_particleCounts.y - 2; p.y += k_workGroupSize2D.y) {
                for (p.x = workI2D.x; p.x < u_particleCounts.x; p.x += k_workGroupSize2D.x) {
                    int pI = p.y * u_particleCounts.x + p.x;
                    constrain(pI, pI + u_particleCounts.x * 2, w2);
                }
            }
            for (ivec2 p = ivec2(0, workI2D.y); p.y < u_particleCounts.y - 2; p.y += k_workGroupSize2D.y) {
                for (p.x = workI2D.x; p.x < u_particleCounts.x - 2; p.x += k_workGroupSize2D.x) {
                    int pI = p.y * u_particleCounts.x + p.x;
                    constrain(pI, pI + u_particleCounts.x * 2 + 2, w3);
                    constrain(pI + 2, pI + u_particleCounts.x * 2, w3);
                }
            }
        }
    }

    barrier();

    // Update particles
    if (isThread2D) {
        for (ivec2 p = ivec2(0, workI2D.y); p.y < u_particleCounts.y; p.y += k_workGroupSize2D.y) {
            for (p.x = workI2D.x; p.x < u_particleCounts.x; p.x += k_workGroupSize2D.x) {
                update(p.y * u_particleCounts.x + p.x);
            }
        }
    }

    barrier();

    // Calculate normals
    if (isThread2D) {
        for (ivec2 p = ivec2(0, workI2D.y); p.y < u_particleCounts.y; p.y += k_workGroupSize2D.y) {
            for (p.x = workI2D.x; p.x < u_particleCounts.x; p.x += k_workGroupSize2D.x) {
                calcNormal(p);
            }
        }
    }
}