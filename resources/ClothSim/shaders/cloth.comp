#version 450 core

#extension GL_NV_shader_atomic_float : enable

layout (local_size_x = WORK_GROUP_SIZE, local_size_y = 1, local_size_z = 1) in;

// Types -----------------------------------------------------------------------

struct Vertex {
    vec3 position;
    float mass;
    vec3 normal;
    float _0;
    vec3 force;
    float constraintFactor;
    vec3 prevPosition;
    int _1;
};

struct Constraint {
    int i;
    int j;
    float d;
    float padding0;
};

// Constants -------------------------------------------------------------------

const int k_workGroupSize = WORK_GROUP_SIZE;
const int k_constraintPasses = CONSTRAINT_PASSES;

const float k_pi = 3.14159265f;
const float k_sqrt2 = 1.41421356f;
const float k_damping = 0.01f;
const bool k_doGravity = true;
const bool k_doSphere = false;
const bool k_doWind = false;
const float k_sphereRadius = 0.4f;
const float k_sphereRadius2 = k_sphereRadius * k_sphereRadius;
const vec3 k_sphereStartP = vec3(0.0f, -0.25f, 1.0f);
const vec3 k_sphereEndP = vec3(0.0f, -0.25f, -1.0f);
const vec3 k_wind = vec3(0.0f, 0.0f, -30.0f);

// Uniforms --------------------------------------------------------------------

uniform int u_vertexCount;
uniform int u_constraintCount;
uniform float u_dt;
uniform vec3 u_gravity;
uniform float u_time;

layout (binding = 0, std430) restrict buffer Vertices {
    Vertex u_vertices[];
};

layout (binding = 2, std430) restrict buffer Constraints {
    Constraint u_constraints[];
};

// Shared ----------------------------------------------------------------------

// Functions -------------------------------------------------------------------

void update(int vi) {
    Vertex vertex = u_vertices[vi];
    vec3 pos = vertex.position;
    if (vertex.mass > 0.0f) {
        vec3 acceleration = vertex.force / vertex.mass;
        if (k_doGravity) acceleration += u_gravity;
        vertex.position += (pos - vertex.prevPosition) * (1.0f - k_damping) + acceleration * u_dt * u_dt;
    }
    vertex.force = vec3(0.0f);
    vertex.prevPosition = pos;
    u_vertices[vi] = vertex;
}

void constrain(Constraint c) {
    vec3 delta = u_vertices[c.j].position - u_vertices[c.i].position;
    vec3 correction = delta * (1.0f - c.d / length(delta));
    float m1 = u_vertices[c.i].mass;
    float m2 = u_vertices[c.j].mass;
    if (m1 > 0.0f || m2 > 0.0f) {
        float p = m1 / (m1 + m2);
        vec3 c1 = correction * p;
        vec3 c2 = correction * (p - 1.0f);
        atomicAdd(u_vertices[c.i].force.x, c1.x);
        atomicAdd(u_vertices[c.i].force.y, c1.y);
        atomicAdd(u_vertices[c.i].force.z, c1.z);
        atomicAdd(u_vertices[c.j].force.x, c2.x);
        atomicAdd(u_vertices[c.j].force.y, c2.y);
        atomicAdd(u_vertices[c.j].force.z, c2.z);
    }
}

void finishConstrain(int vi) {
    Vertex vertex = u_vertices[vi];
    vertex.position += vertex.force * vertex.constraintFactor;
    vertex.force = vec3(0.0f);
    u_vertices[vi] = vertex;
}

void main() {
    const int workI = int(gl_LocalInvocationIndex);

    if (k_doSphere) {
        vec3 sphereOrigin = mix(k_sphereStartP, k_sphereEndP, u_time);
        for (int vi = workI; vi < u_vertexCount; vi += k_workGroupSize) {
            vec3 pos = u_vertices[vi].position;
            vec3 d = pos - sphereOrigin;
            float dist2 = dot(d, d);
            if (dist2 < k_sphereRadius2) {
                u_vertices[vi].position = sphereOrigin + d / sqrt(dist2) * k_sphereRadius;
            }
        }
    }
    else if (k_doWind) {
        for (int vi = workI; vi < u_vertexCount; vi += k_workGroupSize) {
            vec3 norm = u_vertices[vi].normal;
            norm.z = abs(norm.z);
            u_vertices[vi].force += norm * dot(norm, k_wind);
        }
    }
    barrier();

    // Update vertices
    if (true)
    for (int vi = workI; vi < u_vertexCount; vi += k_workGroupSize) {
        update(vi);
    }
    barrier();

    // Constrain
    if (true)
    for (int pass = 0; pass < k_constraintPasses; ++pass) {
        for (int ci = workI; ci < u_constraintCount; ci += k_workGroupSize) {
            constrain(u_constraints[ci]);
            barrier();
        }
        barrier();
        for (int vi = workI; vi < u_vertexCount; vi += k_workGroupSize) {
            finishConstrain(vi);
        }
        barrier();
    }
}



/* Old constrain code just in case I need it

    if (false)
    if (isThread2D) {
        float w0 = u_weaveSize;
        float w1 = w0 * k_sqrt2;
        float w2 = w0 * 2.0f;
        float w3 = w2 * k_sqrt2;
        for (int pass = 0; pass < k_constrainPasses; ++pass) {
            // -
            for (ivec2 p = ivec2(0, workI2D.y); p.y < u_vertexCounts.y; p.y += k_workGroupSize2D.y) {
                for (p.x = workI2D.x; p.x < u_vertexCounts.x - 1; p.x += k_workGroupSize2D.x) {
                    int pi = p.y * u_vertexCounts.x + p.x;
                    constrain(vi, vi + 1, w0);
                }
            }
            barrier();

            // |
            for (ivec2 p = ivec2(0, workI2D.y); p.y < u_vertexCounts.y - 1; p.y += k_workGroupSize2D.y) {
                for (p.x = workI2D.x; p.x < u_vertexCounts.x; p.x += k_workGroupSize2D.x) {
                    int vi = p.y * u_vertexCounts.x + p.x;
                    constrain(vi, vi + u_vertexCounts.x, w0);
                }
            }
            barrier();
            
            // X
            for (ivec2 p = ivec2(0, workI2D.y); p.y < u_vertexCounts.y - 1; p.y += k_workGroupSize2D.y) {
                for (p.x = workI2D.x; p.x < u_vertexCounts.x - 1; p.x += k_workGroupSize2D.x) {
                    int vi = p.y * u_vertexCounts.x + p.x;
                    constrain(vi, vi + u_vertexCounts.x + 1, w1);
                    constrain(vi + 1, vi + u_vertexCounts.x, w1);
                }
            }
            barrier();            
            
            // --
            for (ivec2 p = ivec2(0, workI2D.y); p.y < u_vertexCounts.y; p.y += k_workGroupSize2D.y) {
                for (p.x = workI2D.x; p.x < u_vertexCounts.x - 2; p.x += k_workGroupSize2D.x) {
                    int vi = p.y * u_vertexCounts.x + p.x;
                    constrain(vi, vi + 2, w2);
                }
            }
            barrier();

            // ||
            for (ivec2 p = ivec2(0, workI2D.y); p.y < u_vertexCounts.y - 2; p.y += k_workGroupSize2D.y) {
                for (p.x = workI2D.x; p.x < u_vertexCounts.x; p.x += k_workGroupSize2D.x) {
                    int vi = p.y * u_vertexCounts.x + p.x;
                    constrain(vi, vi + u_vertexCounts.x * 2, w2);
                }
            }
            barrier();
            
            // XX
            for (ivec2 p = ivec2(0, workI2D.y); p.y < u_vertexCounts.y - 2; p.y += k_workGroupSize2D.y) {
                for (p.x = workI2D.x; p.x < u_vertexCounts.x - 2; p.x += k_workGroupSize2D.x) {
                    int vi = p.y * u_vertexCounts.x + p.x;
                    constrain(vi, vi + u_vertexCounts.x * 2 + 2, w3);
                    constrain(vi + 2, vi + u_vertexCounts.x * 2, w3);
                }
            }
            barrier();

            finishConstrainAll(workI2D);
            barrier();
        }
    }

    if (false)
    if (isThread2D) {
        float w0 = u_weaveSize;
        float w1 = w0 * k_sqrt2;
        float w2 = w0 * 2.0f;
        float w3 = w2 * k_sqrt2;
        for (int pass = 0; pass < k_constrainPasses; ++pass) {
            // -
            for (ivec2 p = ivec2(0, workI2D.y); p.y < u_vertexCounts.y; p.y += k_workGroupSize2D.y) {
                for (p.x = workI2D.x * 2; p.x < u_vertexCounts.x - 1; p.x += k_workGroupSize2D.x * 2) {
                    int vi = p.y * u_vertexCounts.x + p.x;
                    constrain(vi, vi + 1, w0);
                }
            }
            barrier();
            for (ivec2 p = ivec2(0, workI2D.y); p.y < u_vertexCounts.y; p.y += k_workGroupSize2D.y) {
                for (p.x = workI2D.x * 2 + 1; p.x < u_vertexCounts.x - 1; p.x += k_workGroupSize2D.x * 2) {
                    int vi = p.y * u_vertexCounts.x + p.x;
                    constrain(vi, vi + 1, w0);
                }
            }
            barrier();

            // |
            for (ivec2 p = ivec2(0, workI2D.y * 2); p.y < u_vertexCounts.y - 1; p.y += k_workGroupSize2D.y * 2) {
                for (p.x = workI2D.x; p.x < u_vertexCounts.x; p.x += k_workGroupSize2D.x) {
                    int vi = p.y * u_vertexCounts.x + p.x;
                    constrain(vi, vi + u_vertexCounts.x, w0);
                }
            }
            barrier();
            for (ivec2 p = ivec2(0, workI2D.y * 2 + 1); p.y < u_vertexCounts.y - 1; p.y += k_workGroupSize2D.y * 2) {
                for (p.x = workI2D.x; p.x < u_vertexCounts.x; p.x += k_workGroupSize2D.x) {
                    int vi = p.y * u_vertexCounts.x + p.x;
                    constrain(vi, vi + u_vertexCounts.x, w0);
                }
            }
            barrier();
            
            // X
            for (ivec2 p = ivec2(0, workI2D.y * 2); p.y < u_vertexCounts.y - 1; p.y += k_workGroupSize2D.y * 2) {
                for (p.x = workI2D.x * 2; p.x < u_vertexCounts.x - 1; p.x += k_workGroupSize2D.x * 2) {
                    int vi = p.y * u_vertexCounts.x + p.x;
                    constrain(vi, vi + u_vertexCounts.x + 1, w1);
                    constrain(vi + 1, vi + u_vertexCounts.x, w1);
                }
            }
            barrier();
            for (ivec2 p = ivec2(0, workI2D.y * 2); p.y < u_vertexCounts.y - 1; p.y += k_workGroupSize2D.y * 2) {
                for (p.x = workI2D.x * 2 + 1; p.x < u_vertexCounts.x - 1; p.x += k_workGroupSize2D.x * 2) {
                    int vi = p.y * u_vertexCounts.x + p.x;
                    constrain(vi, vi + u_vertexCounts.x + 1, w1);
                    constrain(vi + 1, vi + u_vertexCounts.x, w1);
                }
            }
            barrier();
            for (ivec2 p = ivec2(0, workI2D.y * 2 + 1); p.y < u_vertexCounts.y - 1; p.y += k_workGroupSize2D.y * 2) {
                for (p.x = workI2D.x * 2; p.x < u_vertexCounts.x - 1; p.x += k_workGroupSize2D.x * 2) {
                    int vi = p.y * u_vertexCounts.x + p.x;
                    constrain(vi, vi + u_vertexCounts.x + 1, w1);
                    constrain(vi + 1, vi + u_vertexCounts.x, w1);
                }
            }
            barrier();
            for (ivec2 p = ivec2(0, workI2D.y * 2 + 1); p.y < u_vertexCounts.y - 1; p.y += k_workGroupSize2D.y * 2) {
                for (p.x = workI2D.x * 2 + 1; p.x < u_vertexCounts.x - 1; p.x += k_workGroupSize2D.x * 2) {
                    int vi = p.y * u_vertexCounts.x + p.x;
                    constrain(vi, vi + u_vertexCounts.x + 1, w1);
                    constrain(vi + 1, vi + u_vertexCounts.x, w1);
                }
            }
            barrier();

            
            
            // --
            for (ivec2 p = ivec2(0, workI2D.y); p.y < u_vertexCounts.y; p.y += k_workGroupSize2D.y) {
                for (p.x = workI2D.x * 3; p.x < u_vertexCounts.x - 2; p.x += k_workGroupSize2D.x * 3) {
                    int vi = p.y * u_vertexCounts.x + p.x;
                    constrain(vi, vi + 2, w2);
                }
            }
            barrier();
            for (ivec2 p = ivec2(0, workI2D.y); p.y < u_vertexCounts.y; p.y += k_workGroupSize2D.y) {
                for (p.x = workI2D.x * 3 + 1; p.x < u_vertexCounts.x - 2; p.x += k_workGroupSize2D.x * 3) {
                    int vi = p.y * u_vertexCounts.x + p.x;
                    constrain(vi, vi + 2, w2);
                }
            }
            barrier();
            for (ivec2 p = ivec2(0, workI2D.y); p.y < u_vertexCounts.y; p.y += k_workGroupSize2D.y) {
                for (p.x = workI2D.x * 3 + 2; p.x < u_vertexCounts.x - 2; p.x += k_workGroupSize2D.x * 3) {
                    int vi = p.y * u_vertexCounts.x + p.x;
                    constrain(vi, vi + 2, w2);
                }
            }
            barrier();

            // ||
            for (ivec2 p = ivec2(0, workI2D.y * 3); p.y < u_vertexCounts.y - 2; p.y += k_workGroupSize2D.y * 3) {
                for (p.x = workI2D.x; p.x < u_vertexCounts.x; p.x += k_workGroupSize2D.x) {
                    int vi = p.y * u_vertexCounts.x + p.x;
                    constrain(vi, vi + u_vertexCounts.x * 2, w2);
                }
            }
            barrier();
            for (ivec2 p = ivec2(0, workI2D.y * 3 + 1); p.y < u_vertexCounts.y - 2; p.y += k_workGroupSize2D.y * 3) {
                for (p.x = workI2D.x; p.x < u_vertexCounts.x; p.x += k_workGroupSize2D.x) {
                    int vi = p.y * u_vertexCounts.x + p.x;
                    constrain(vi, vi + u_vertexCounts.x * 2, w2);
                }
            }
            barrier();
            for (ivec2 p = ivec2(0, workI2D.y * 3 + 2); p.y < u_vertexCounts.y - 2; p.y += k_workGroupSize2D.y * 3) {
                for (p.x = workI2D.x; p.x < u_vertexCounts.x; p.x += k_workGroupSize2D.x) {
                    int vi = p.y * u_vertexCounts.x + p.x;
                    constrain(vi, vi + u_vertexCounts.x * 2, w2);
                }
            }
            barrier();
            
            // XX
            for (ivec2 p = ivec2(0, workI2D.y * 3); p.y < u_vertexCounts.y - 2; p.y += k_workGroupSize2D.y * 3) {
                for (p.x = workI2D.x * 3; p.x < u_vertexCounts.x - 2; p.x += k_workGroupSize2D.x * 3) {
                    int vi = p.y * u_vertexCounts.x + p.x;
                    constrain(vi, vi + u_vertexCounts.x * 2 + 2, w3);
                    constrain(vi + 2, vi + u_vertexCounts.x * 2, w3);
                }
            }
            barrier();
            for (ivec2 p = ivec2(0, workI2D.y * 3); p.y < u_vertexCounts.y - 2; p.y += k_workGroupSize2D.y * 3) {
                for (p.x = workI2D.x * 3 + 1; p.x < u_vertexCounts.x - 2; p.x += k_workGroupSize2D.x * 3) {
                    int vi = p.y * u_vertexCounts.x + p.x;
                    constrain(vi, vi + u_vertexCounts.x * 2 + 2, w3);
                    constrain(vi + 2, vi + u_vertexCounts.x * 2, w3);
                }
            }
            barrier();
            for (ivec2 p = ivec2(0, workI2D.y * 3); p.y < u_vertexCounts.y - 2; p.y += k_workGroupSize2D.y * 3) {
                for (p.x = workI2D.x * 3 + 2; p.x < u_vertexCounts.x - 2; p.x += k_workGroupSize2D.x * 3) {
                    int vi = p.y * u_vertexCounts.x + p.x;
                    constrain(vi, vi + u_vertexCounts.x * 2 + 2, w3);
                    constrain(vi + 2, vi + u_vertexCounts.x * 2, w3);
                }
            }
            barrier();
            for (ivec2 p = ivec2(0, workI2D.y * 3 + 1); p.y < u_vertexCounts.y - 2; p.y += k_workGroupSize2D.y * 3) {
                for (p.x = workI2D.x * 3; p.x < u_vertexCounts.x - 2; p.x += k_workGroupSize2D.x * 3) {
                    int vi = p.y * u_vertexCounts.x + p.x;
                    constrain(vi, vi + u_vertexCounts.x * 2 + 2, w3);
                    constrain(vi + 2, vi + u_vertexCounts.x * 2, w3);
                }
            }
            barrier();
            for (ivec2 p = ivec2(0, workI2D.y * 3 + 1); p.y < u_vertexCounts.y - 2; p.y += k_workGroupSize2D.y * 3) {
                for (p.x = workI2D.x * 3 + 1; p.x < u_vertexCounts.x - 2; p.x += k_workGroupSize2D.x * 3) {
                    int vi = p.y * u_vertexCounts.x + p.x;
                    constrain(vi, vi + u_vertexCounts.x * 2 + 2, w3);
                    constrain(vi + 2, vi + u_vertexCounts.x * 2, w3);
                }
            }
            barrier();
            for (ivec2 p = ivec2(0, workI2D.y * 3 + 1); p.y < u_vertexCounts.y - 2; p.y += k_workGroupSize2D.y * 3) {
                for (p.x = workI2D.x * 3 + 2; p.x < u_vertexCounts.x - 2; p.x += k_workGroupSize2D.x * 3) {
                    int vi = p.y * u_vertexCounts.x + p.x;
                    constrain(vi, vi + u_vertexCounts.x * 2 + 2, w3);
                    constrain(vi + 2, vi + u_vertexCounts.x * 2, w3);
                }
            }
            barrier();
            for (ivec2 p = ivec2(0, workI2D.y * 3 + 2); p.y < u_vertexCounts.y - 2; p.y += k_workGroupSize2D.y * 3) {
                for (p.x = workI2D.x * 3; p.x < u_vertexCounts.x - 2; p.x += k_workGroupSize2D.x * 3) {
                    int vi = p.y * u_vertexCounts.x + p.x;
                    constrain(vi, vi + u_vertexCounts.x * 2 + 2, w3);
                    constrain(vi + 2, vi + u_vertexCounts.x * 2, w3);
                }
            }
            barrier();
            for (ivec2 p = ivec2(0, workI2D.y * 3 + 2); p.y < u_vertexCounts.y - 2; p.y += k_workGroupSize2D.y * 3) {
                for (p.x = workI2D.x * 3 + 1; p.x < u_vertexCounts.x - 2; p.x += k_workGroupSize2D.x * 3) {
                    int vi = p.y * u_vertexCounts.x + p.x;
                    constrain(vi, vi + u_vertexCounts.x * 2 + 2, w3);
                    constrain(vi + 2, vi + u_vertexCounts.x * 2, w3);
                }
            }
            barrier();
            for (ivec2 p = ivec2(0, workI2D.y * 3 + 2); p.y < u_vertexCounts.y - 2; p.y += k_workGroupSize2D.y * 3) {
                for (p.x = workI2D.x * 3 + 2; p.x < u_vertexCounts.x - 2; p.x += k_workGroupSize2D.x * 3) {
                    int vi = p.y * u_vertexCounts.x + p.x;
                    constrain(vi, vi + u_vertexCounts.x * 2 + 2, w3);
                    constrain(vi + 2, vi + u_vertexCounts.x * 2, w3);
                }
            }
            barrier();

            finishConstrainAll(workI2D);
            barrier();
        }
    }

*/