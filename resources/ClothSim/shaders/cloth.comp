#version 450 core

#extension GL_NV_shader_atomic_float : enable

layout (local_size_x = WORK_GROUP_SIZE, local_size_y = 1, local_size_z = 1) in;

// Types -----------------------------------------------------------------------

struct Vertex {
    vec3 position;
    float mass;
    vec3 normal;
    float _0;
    vec3 force;
    float _1;
    vec3 prevPosition;
    float _2;
};

struct Constraint {
    int i;
    int j;
    float d;
    float padding0;
};

// Constants -------------------------------------------------------------------

// External
const int k_workGroupSize = WORK_GROUP_SIZE;
const int k_constraintPasses = CONSTRAINT_PASSES;

const float k_pi = 3.14159265f;
const float k_sqrt2 = 1.41421356f;
const float k_damping = 0.01f;
const bool k_doGravity = false;
const bool k_doSphere = false;
const bool k_doWind = false;
const bool k_doTouch = true;
const float k_sphereRadius = 0.4f;
const float k_sphereRadius2 = k_sphereRadius * k_sphereRadius;
const vec3 k_sphereStartP = vec3(0.0f, -0.25f, 1.0f);
const vec3 k_sphereEndP = vec3(0.0f, -0.25f, -1.0f);
const vec3 k_wind = vec3(0.0f, 0.0f, -30.0f);
const float k_touchMag = 50.0f;
const float k_touchRad = 0.1f;

// Uniforms --------------------------------------------------------------------

uniform int u_vertexCount;
uniform int u_constraintCount;
uniform float u_dt;
uniform vec3 u_gravity;
uniform float u_time;
uniform bool u_isTouch;
uniform vec2 u_touchPos;
uniform vec3 u_touchDir;
uniform mat4 u_touchMat;
uniform vec2 u_aspect;
uniform float u_weaveSize;

layout (binding = 0, std430) restrict buffer Vertices {
    Vertex u_vertices[];
};

layout (binding = 2, std430) restrict buffer Constraints {
    Constraint u_constraints[];
};

// Shared ----------------------------------------------------------------------

// Functions -------------------------------------------------------------------

void update(int vi) {
    Vertex vertex = u_vertices[vi];
    vec3 pos = vertex.position;
    if (vertex.mass > 0.0f) {
        vec3 acceleration = vertex.force / vertex.mass;
        if (k_doGravity) acceleration += u_gravity;
        vertex.position += (pos - vertex.prevPosition) * (1.0f - k_damping) + acceleration * u_dt * u_dt;
    }
    vertex.force = vec3(0.0f);
    vertex.prevPosition = pos;
    u_vertices[vi] = vertex;
}

void constrain(Constraint c) {
    if (c.i == c.j) {
        return;
    }

    vec3 delta = u_vertices[c.j].position - u_vertices[c.i].position;
    vec3 correction = delta * (1.0f - c.d / length(delta));
    float m1 = u_vertices[c.i].mass;
    float m2 = u_vertices[c.j].mass;
    float p = m1 / (m1 + m2);
    vec3 c1 = correction * p;
    vec3 c2 = correction * (p - 1.0f);
    if (m1 > 0.0f) u_vertices[c.i].position += c1;
    if (m2 > 0.0f) u_vertices[c.j].position += c2;
}

float maxDist2;

void collide(int vi1, Vertex v2) {
    if (u_vertices[vi1].mass < 0.0f) {
        return;
    }
    vec3 delta = u_vertices[vi1].position - v2.position;
    float dist2 = dot(delta, delta);
    if (dist2 < maxDist2) {
        u_vertices[vi1].position = v2.position + delta / sqrt(dist2) * u_weaveSize;
    }
}

void collideAll(int workI) {
    for (int vi2 = 0; vi2 < u_vertexCount - 1; ++vi2) {
        Vertex v = u_vertices[vi2];
        for (int vi1 = vi2 + 1 + workI; vi1 < u_vertexCount; vi1 += k_workGroupSize) {
            collide(vi1, v);
        }
        barrier();
    }
}

void main() {
    const int workI = int(gl_LocalInvocationIndex);

    maxDist2 = u_weaveSize * 0.5f;
    maxDist2 *= maxDist2;

    if (k_doSphere) {
        vec3 sphereOrigin = mix(k_sphereStartP, k_sphereEndP, u_time);
        for (int vi = workI; vi < u_vertexCount; vi += k_workGroupSize) {
            vec3 pos = u_vertices[vi].position;
            vec3 d = pos - sphereOrigin;
            float dist2 = dot(d, d);
            if (dist2 < k_sphereRadius2) {
                u_vertices[vi].position = sphereOrigin + d / sqrt(dist2) * k_sphereRadius;
            }
        }
    }
    else if (k_doWind) {
        for (int vi = workI; vi < u_vertexCount; vi += k_workGroupSize) {
            vec3 norm = u_vertices[vi].normal;
            norm.z = abs(norm.z);
            u_vertices[vi].force += norm * dot(norm, k_wind);
        }
    }
    if (k_doTouch && u_isTouch) {
        for (int vi = workI; vi < u_vertexCount; vi += k_workGroupSize) {
            vec4 pos = (u_touchMat * vec4(u_vertices[vi].position, 1.0f));
            pos.xy /= pos.w;
            pos.xy *= u_aspect;
            vec2 delta = pos.xy - u_touchPos;
            float dist2 = dot(delta, delta);
            float strength = max(1.0f - dist2 / (k_touchRad * k_touchRad), 0.0f) * k_touchMag;
            u_vertices[vi].force += u_touchDir * strength;
        }        
    }
    barrier();

    // Update vertices
    for (int vi = workI; vi < u_vertexCount; vi += k_workGroupSize) {
        update(vi);
    }
    barrier();

    // Constrain
    for (int pass = 0; pass < k_constraintPasses; ++pass) {
        for (int ci = workI; ci < u_constraintCount; ci += k_workGroupSize) {
            constrain(u_constraints[ci]);
            barrier();
        }
        barrier();
        //collideAll(workI);
    }
}