#version 450 core

#extension GL_NV_shader_atomic_float : enable

layout (local_size_x = WORK_GROUP_SIZE, local_size_y = 1, local_size_z = 1) in;

// Types -----------------------------------------------------------------------

struct Result {
    vec4 lift;
    vec4 drag;
    vec4 torq;
};

struct GeoPixel {
    vec2 windPos;
    ivec2 texCoord;
    vec4 normal;
};

struct AirPixel {
    vec2 windPos;
    vec2 velocity;
    vec2 backforce;
    vec2 turbulence; // x component is turbulence
};

struct SoftVertex {
    vec3 position;
    float mass;
    vec3 normal;
    int group;
    vec3 prevPosition;
    float _0;
    vec3 force0; // lift
    float _1;
    vec3 force1; // drag
    float _2;
};

// Constants -------------------------------------------------------------------

// External
const ivec2 k_workGroupSize2D = WORK_GROUP_SIZE_2D;
const bool k_debug = DEBUG;
const bool k_doWindShadow = DO_WIND_SHADOW;
const bool k_distinguishActivePixels = DISTINGUISH_ACTIVE_PIXELS; // Makes certain "active" pixels brigher for visual clarity, but lowers performance
const bool k_doTurbulence = DO_TURBULENCE;
const bool k_doCloth = DO_CLOTH;

const int k_workGroupSize = int(gl_WorkGroupSize.x * gl_WorkGroupSize.y * gl_WorkGroupSize.z);
const uint k_geoBit = 1, k_airBit = 2, k_activeBit = 4; // Must also change in other shaders
const float k_airDensity = 1.0f;
const float k_inactiveVal = k_distinguishActivePixels && k_debug ? 1.0f / 3.0f : 1.0f;
const int k_maxEdgeSeekSteps = 64; // Necessary in pathological cases where normals form a loop
const float k_minNormalZ = 1.0f / 1000000.0f;
const float k_maxNormalZ = 1.0f - k_minNormalZ;

// Uniforms --------------------------------------------------------------------

layout (binding = 0,      rgba8ui) uniform restrict uimage2D u_frontImg;
layout (binding = 1, rgba16_snorm) uniform restrict  image2D u_fboNormImg;
layout (binding = 2,         r32i) uniform restrict iimage2D u_flagImg;
layout (binding = 3,           r8) uniform restrict  image2D u_turbImg;
layout (binding = 4,           r8) uniform restrict  image2D u_prevTurbImg;
layout (binding = 5,           r8) uniform restrict  image2D u_shadImg;
layout (binding = 6,        r32ui) uniform restrict uimage2D u_indexImg;

layout (binding = 1) uniform sampler2D u_prevTurbTex;
layout (binding = 2) uniform sampler2D u_shadTex;

// Uniform buffer for better read-only performance
layout (binding = 0, std140) uniform Constants {
    int u_maxGeoPixels;
    int u_maxAirPixels;
    int u_screenSize;
    float u_liftC;
    float u_dragC;
    float u_windframeSize;
    float u_windframeDepth;
    float u_sliceSize;
    float u_turbulenceDist;
    float u_maxSearchDist;
    float u_windShadDist;
    float u_backforceC;
    float u_flowback;
    float u_initVelC;
    float u_windSpeed;
    float u_dt;
    int u_slice;
    float u_sliceZ;
    float u_pixelSize;
};

layout (binding = 0, std430) restrict buffer GeoPixels {
    coherent int u_geoCount;
    int u_GeoPixels_pad0;
    int u_GeoPixels_pad1;
    int u_GeoPixels_pad2;
    GeoPixel u_geoPixels[];
};

layout (binding = 1, std430) restrict buffer AirPixels {
    int u_airCount;
    int u_AirPixels_pad0;
    int u_AirPixels_pad1;
    int u_AirPixels_pad2;
    AirPixel u_airPixels[];
};

layout (binding = 2, std430) restrict buffer PrevAirPixels {
    int u_prevAirCount;
    int u_PrevAirPixels_pad0;
    int u_PrevAirPixels_pad1;
    int u_PrevAirPixels_pad2;
    AirPixel u_prevAirPixels[];
};

layout (binding = 3, std430) restrict buffer AirGeoMap {
    int u_airGeoMap[];
};

layout (binding = 4, std430) restrict buffer Results {
    Result u_results[];
};

// Only present if doing cloth
layout (binding = 5, std430) restrict buffer SoftVertices {
    SoftVertex u_softVertices[];
};

// Only present if doing cloth
layout (binding = 6, std430) restrict buffer Indices {
    uint u_indices[];
};

// Shared ----------------------------------------------------------------------

shared vec3 s_accumulationArray[k_workGroupSize];
shared int s_geoCounts[k_workGroupSize];

// Invocation variables --------------------------------------------------------

vec3 i_lift = vec3(0.0f);
vec3 i_drag = vec3(0.0f);
vec3 i_torq = vec3(0.0f);

// Functions -------------------------------------------------------------------

vec2 safeNormalize(vec2 v) {
    float d = dot(v, v);
    return d > 0.0f ? v / sqrt(d) : vec2(0.0f);
}

vec3 safeNormalize(vec3 v) {
    float d = dot(v, v);
    return d > 0.0f ? v / sqrt(d) : vec3(0.0f);
}

bool isInTexture(ivec2 p, ivec2 texSize) {
    return all(bvec4(greaterThanEqual(p, ivec2(0)), lessThan(p, texSize)));
}

vec2 windToScreen(vec2 wind) {
    return (wind / u_windframeSize + 0.5f) * float(u_screenSize);
}

vec2 screenToWind(vec2 screen) {
    return (screen / u_screenSize - 0.5f) * u_windframeSize;
}

float screenToWindDist(float screenDist) {
    return screenDist / float(u_screenSize) * u_windframeSize;
}

bool isScreenInShadow(vec2 screenPos) {
    return texture2D(u_shadTex, screenPos / u_screenSize).r > 0.0f;
}

bool isScreenTurbulent(vec2 screenPos) {
    return texture2D(u_prevTurbTex, screenPos / u_screenSize).r > 0.0f;
}

bool isWindTurbulent(vec2 windPos) {
    return isScreenTurbulent(windToScreen(windPos));
}

void setScreenTurbulent(vec2 screenPos) {
    imageStore(u_turbImg, ivec2(screenPos * 0.25f), vec4(1.0f, 0.0f, 0.0f, 0.0f));
}

void setWindTurbulent(vec2 windPos) {
    setScreenTurbulent(windToScreen(windPos));
}

float getShadFactor(float shad) {
    float shadDepth = shad * u_windframeDepth;
    float currDepth = u_slice * u_sliceSize;
    return float(shad != 0.0f) * max((1.0f - (currDepth - shadDepth) / u_windShadDist), 0.0f);
}

float getScreenShadFactor(vec2 screenPos) {
    return getShadFactor(texture2D(u_shadTex, screenPos / u_screenSize).r);
}

float getWindShadFactor(vec2 windPos) {
    return getScreenShadFactor(windToScreen(windPos));
}

// Returns one of <1, 0>, <-1, 0>, <0, 1>, <0, -1> corresponding to dir
ivec2 getPixelDelta(vec2 dir) {
    vec2 signs = sign(dir);
    vec2 mags = dir * signs;
    if (mags.y >= mags.x) {
        return ivec2(0, int(signs.y));
    }
    else {
        return ivec2(int(signs.x), 0);
    }
}