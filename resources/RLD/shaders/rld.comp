#version 450 core

layout (local_size_x = WORK_GROUP_SIZE, local_size_y = 1, local_size_z = 1) in;

// Types -----------------------------------------------------------------------

struct Result {
    vec4 lift;
    vec4 drag;
    vec4 torq;
};

struct GeoPixel {
    vec2 windPos;
    ivec2 texCoord;
    vec4 normal;
};

struct AirPixel {
    vec2 windPos;
    vec2 velocity;
    vec2 backforce;
    vec2 turbulence; // x component is turbulence
};

// Constants -------------------------------------------------------------------

// External defines
const int k_workGroupSize = WORK_GROUP_SIZE;
const ivec2 k_workGroupSize2D = WORK_GROUP_SIZE_2D;
const bool k_debug = DEBUG;
const bool k_doWindShadow = DO_WIND_SHADOW;
const bool k_distinguishActivePixels = DISTINGUISH_ACTIVE_PIXELS; // Makes certain "active" pixels brigher for visual clarity, but lowers performance
const bool k_doTurbulence = DO_TURBULENCE;

const uint k_geoBit = 1, k_airBit = 2, k_activeBit = 4; // Must also change in other shaders
const float k_airDensity = 1.0f;
const float k_inactiveVal = k_distinguishActivePixels && k_debug ? 1.0f / 3.0f : 1.0f;
const int k_maxEdgeSeekSteps = 64; // Necessary in pathological cases where normals form a loop
const float k_minNormalZ = 1.0f / 1000000.0f;
const float k_maxNormalZ = 1.0f - k_minNormalZ;

// Uniforms --------------------------------------------------------------------

layout (binding = 0,      rgba8ui) uniform uimage2D u_frontImg;
layout (binding = 1, rgba16_snorm) uniform  image2D u_fboNormImg;
layout (binding = 2,         r32i) uniform iimage2D u_flagImg;
layout (binding = 3,           r8) uniform  image2D u_turbImg;
layout (binding = 4,           r8) uniform  image2D u_prevTurbImg;
layout (binding = 5,           r8) uniform  image2D u_shadImg;

layout (binding = 1) uniform sampler2D u_prevTurbTex;
layout (binding = 2) uniform sampler2D u_shadTex;

// Uniform buffer for better read-only performance
layout (binding = 0, std140) uniform Constants {
    int u_maxGeoPixels;
    int u_maxAirPixels;
    int u_screenSize;
    float u_liftC;
    float u_dragC;
    float u_windframeSize;
    float u_windframeDepth;
    float u_sliceSize;
    float u_turbulenceDist;
    float u_maxSearchDist;
    float u_windShadDist;
    float u_backforceC;
    float u_flowback;
    float u_initVelC;
    float u_windSpeed;
    float u_dt;
    int u_slice;
    float u_sliceZ;
    float u_pixelSize;
};

layout (binding = 0, std430) restrict buffer GeoPixels {
    coherent int u_geoCount;
    int u_GeoPixels_pad0;
    int u_GeoPixels_pad1;
    int u_GeoPixels_pad2;
    GeoPixel u_geoPixels[];
};

layout (binding = 1, std430) restrict buffer AirPixels {
    int u_airCount;
    int u_AirPixels_pad0;
    int u_AirPixels_pad1;
    int u_AirPixels_pad2;
    AirPixel u_airPixels[];
};

layout (binding = 2, std430) restrict buffer PrevAirPixels {
    int u_prevAirCount;
    int u_PrevAirPixels_pad0;
    int u_PrevAirPixels_pad1;
    int u_PrevAirPixels_pad2;
    AirPixel u_prevAirPixels[];
};

layout (binding = 3, std430) restrict buffer AirGeoMap {
    int u_airGeoMap[];
};

layout (binding = 4, std430) restrict buffer Results {
    Result u_results[];
};

// Shared ----------------------------------------------------------------------

shared vec3 s_accumulationArray[k_workGroupSize];
shared int s_geoCounts[k_workGroupSize];

// Invocation variables --------------------------------------------------------

vec3 totalLift = vec3(0.0f);
vec3 totalDrag = vec3(0.0f);
vec3 totalTorq = vec3(0.0f);

// Functions -------------------------------------------------------------------

vec2 safeNormalize(vec2 v) {
    float d = dot(v, v);
    return d > 0.0f ? v / sqrt(d) : vec2(0.0f);
}

vec3 safeNormalize(vec3 v) {
    float d = dot(v, v);
    return d > 0.0f ? v / sqrt(d) : vec3(0.0f);
}

vec2 windToScreen(vec2 wind) {
    return (wind / u_windframeSize + 0.5f) * float(u_screenSize);
}

vec2 screenToWind(vec2 screen) {
    return (screen / u_screenSize - 0.5f) * u_windframeSize;
}

float screenToWindDist(float screenDist) {
    return screenDist / float(u_screenSize) * u_windframeSize;
}

bool isScreenInShadow(vec2 screenPos) {
    return texture2D(u_shadTex, screenPos / u_screenSize).r > 0.0f;
}

bool isScreenTurbulent(vec2 screenPos) {
    return texture2D(u_prevTurbTex, screenPos / u_screenSize).r > 0.0f;
}

bool isWindTurbulent(vec2 windPos) {
    return isScreenTurbulent(windToScreen(windPos));
}

void setScreenTurbulent(vec2 screenPos) {
    imageStore(u_turbImg, ivec2(screenPos * 0.25f), vec4(1.0f, 0.0f, 0.0f, 0.0f));
}

void setWindTurbulent(vec2 windPos) {
    setScreenTurbulent(windToScreen(windPos));
}

float getShadFactor(float shad) {
    float shadDepth = shad * u_windframeDepth;
    float currDepth = u_slice * u_sliceSize;
    return float(shad != 0.0f) * max((1.0f - (currDepth - shadDepth) / u_windShadDist), 0.0f);
}

float getScreenShadFactor(vec2 screenPos) {
    return getShadFactor(texture2D(u_shadTex, screenPos / u_screenSize).r);
}

float getWindShadFactor(vec2 windPos) {
    return getScreenShadFactor(windToScreen(windPos));
}

// Returns one of <1, 0>, <-1, 0>, <0, 1>, <0, -1> corresponding to dir
ivec2 getPixelDelta(vec2 dir) {
    vec2 signs = sign(dir);
    vec2 mags = dir * signs;
    if (mags.y >= mags.x) {
        return ivec2(0, int(signs.y));
    }
    else {
        return ivec2(int(signs.x), 0);
    }
}

void accumulate() {
    int workI = int(gl_LocalInvocationIndex);
    for (int n = k_workGroupSize / 2; n > 0; n /= 2) {
        barrier();
        if (workI < n) s_accumulationArray[workI] += s_accumulationArray[workI + n];
    }
}

// Prospect --------------------------------------------------------------------

void prospect(ivec2 texCoord) {
    // If not geometry, ignore
    uvec4 color = imageLoad(u_frontImg, texCoord);
    if ((color.r & k_geoBit) == 0) {
        return;
    }

    vec2 geoWindPos = screenToWind(vec2(texCoord) + color.gb / 255.0f);
    vec3 geoNormal = imageLoad(u_fboNormImg, texCoord).xyz;

    // Set wind shadow
    if (k_doWindShadow && geoNormal.z < 0.0f) { // TODO: do we want a minimum angle for wind shadow?
        imageStore(u_shadImg, texCoord / 4, vec4(u_slice * u_sliceSize / u_windframeDepth, 0.0f, 0.0f, 0.0f));
    }
    // Calculate drag and torque
    else if (!isScreenInShadow(vec2(texCoord) + 0.5f)) {
        float dragFactor = 0.5f * k_airDensity * u_windSpeed * u_windSpeed * u_pixelSize * u_pixelSize * geoNormal.z;
        dragFactor *= u_dragC;
        vec3 drag = -geoNormal * dragFactor;
        totalDrag += drag;

        vec3 torq = cross(vec3(geoWindPos, u_sliceZ), drag); // TODO: is this right
        totalTorq += torq;
    }

    ivec2 nextTexCoord = texCoord + getPixelDelta(geoNormal.xy);
    uvec4 nextColor = imageLoad(u_frontImg, nextTexCoord);
    if ((nextColor.r & k_geoBit) != 0) {
        return;
    }

    int geoI = atomicAdd(u_geoCount, 1);
    if (geoI >= u_maxGeoPixels) {
        return;
    }

    u_geoPixels[geoI].windPos = geoWindPos.xy;
    u_geoPixels[geoI].normal = vec4(geoNormal, 0.0f);
    u_geoPixels[geoI].texCoord = texCoord;
}

// Draw ------------------------------------------------------------------------

void draw(int prevAirI) {
    AirPixel air = u_prevAirPixels[prevAirI];
    ivec2 airTexCoord = ivec2(windToScreen(air.windPos));

    // Check if in texture
    if (airTexCoord.x < 0 || airTexCoord.y < 0 || airTexCoord.x >= u_screenSize || airTexCoord.y >= u_screenSize) {
        return;
    }

    uvec4 color = imageLoad(u_frontImg, airTexCoord);

    // If in geometry, follow the geo normals to find the edge
    if ((color.r & k_geoBit) != 0) {
        ivec2 pixel = airTexCoord;
        int steps = 0;
        while (true) {
            vec3 geoNormal = imageLoad(u_fboNormImg, airTexCoord).xyz;
            if (abs(geoNormal.z) > k_maxNormalZ) {
                return;
            }
            ivec2 nextPixel = pixel + getPixelDelta(geoNormal.xy);
            uvec4 nextColor = imageLoad(u_frontImg, nextPixel);

            // We found the edge, move air to it
            if ((nextColor.r & k_geoBit) == 0) {
                airTexCoord = pixel;

                //vec3 tangentVel = cross(geoNormal, cross(geoNormal, vec3(0.0f, 0.0f, 1.0f))); // TODO
                //vec2 tangentVel = geoNormal.xy * geoNormal.z; // Equivalent to above
                //tangentVel = tangentVel * u_windSpeed;

                // Set air to same position as geometry
                air.windPos = screenToWind(vec2(airTexCoord) + vec2(imageLoad(u_frontImg, airTexCoord).gb) / 255.0f);

                vec2 norm = normalize(geoNormal.xy);
                if (geoNormal.z > 0.0f) {
                    air.velocity = max(dot(air.velocity, norm), geoNormal.z * u_windSpeed) * norm;
                }
                else {
                    air.velocity = geoNormal.z * u_windSpeed * norm;
                }

                air.backforce = vec2(0.0f);
                air.turbulence = vec2(0.0f);
                break;
            }

            // If air "inside" geometry, get rid of it, unless it's on the very edge
            if (geoNormal.z < 0.0f) {
                return;
            }

            pixel = nextPixel;
            color = nextColor;
            if (++steps >= k_maxEdgeSeekSteps) {
                return;
            }
        }
    }

    // Air already exists at pixel
    if ((color.r & k_airBit) != 0) {
        return;
    }

    // Move to current air pixel buffer
    int airI = atomicAdd(u_airCount, 1);
    if (airI >= u_maxAirPixels) {
        return;
    }
    u_airPixels[airI] = air;
    u_airGeoMap[airI] = 0; // This air pixel is not yet associated with any geometry

    // Store air index
    imageStore(u_flagImg, airTexCoord, ivec4(airI + 1, 0, 0, 0));

    // Draw to front view
    color.r |= k_airBit;
    imageStore(u_frontImg, airTexCoord, color);
}

// Outline ---------------------------------------------------------------------

void outline(int geoI) {
    vec2 geoWindPos = u_geoPixels[geoI].windPos;
    vec3 geoNormal = u_geoPixels[geoI].normal.xyz;
    ivec2 geoTexCoord = u_geoPixels[geoI].texCoord; // Need exact texture coord because rasterization math and our wind-to-screen math don't always align
    vec2 geoScreenPos = windToScreen(geoWindPos);
    geoScreenPos = clamp(geoScreenPos, vec2(geoTexCoord), vec2(geoTexCoord + 1)); // necessary for edge cases

    bool shouldSpawn = geoNormal.z >= k_minNormalZ && geoNormal.z <= k_maxNormalZ;
    bool shouldSearch = true;

    // If geo is in turbulence, forget it
    if (k_doTurbulence && isScreenTurbulent(geoScreenPos)) {
        shouldSearch = false;
        shouldSpawn = false;
    }

    // Look for existing air pixel
    if (shouldSearch) {
        vec2 searchScreenPos = geoScreenPos;
        ivec2 searchPixel = geoTexCoord;
        vec2 searchDir = normalize(geoNormal.xy);
        vec2 corner = step(vec2(0.0f), searchDir);
        float totalDist = 0.0f;

        // Check for air on geometry
        uvec4 color = imageLoad(u_frontImg, searchPixel);
        if ((color.r & k_airBit) != 0) {
            int airI = imageLoad(u_flagImg, searchPixel).x;
            if (airI != 0) { // TODO: this should not be necessary, just here for sanity
                --airI;

                shouldSpawn = false;

                u_airGeoMap[airI] = geoI + 1;
            }
        }

        // Search along line in direction of geo normal
        if (shouldSpawn)
        while (true) {
            // TODO: potentially optimize line search
            vec2 delta = corner - (searchScreenPos - vec2(searchPixel));
            vec2 dist = abs(delta / searchDir);
            if (dist.x < dist.y) {
                searchScreenPos += searchDir * dist.x;
                searchPixel.x += int(sign(searchDir.x));
                totalDist += screenToWindDist(dist.x);
            }
            else {
                searchScreenPos += searchDir * dist.y;
                searchPixel.y += int(sign(searchDir.y));
                totalDist += screenToWindDist(dist.y);
            }

            if (totalDist > u_maxSearchDist) {
                break;
            }

            // If find turbulence, stop looking and mark turbulence
            if (k_doTurbulence && isScreenTurbulent(searchScreenPos)) {
                // Write turbulence pixel half way between found turbulence and geometry
                setScreenTurbulent((geoScreenPos + searchScreenPos) * 0.5f);

                shouldSpawn = false;
                break;
            }

            color = imageLoad(u_frontImg, searchPixel);

            // Visualize the search
            //if (k_debug) {
            //    imageStore(u_fboImg, pixel, vec4(color.r, color.g, 0.5f, color.a));
            //}

            if ((color.r & k_geoBit) != 0) { // we found a geo pixel
                break;
            }
            if ((color.r & k_airBit) != 0) { // we found an air pixel
                int airI = imageLoad(u_flagImg, searchPixel).x;
                if (airI != 0) { // TODO: this should not be necessary, just here for sanity
                    --airI;

                    // If past turbulence distance, set air as turbulent and mark turbulance
                    if (k_doTurbulence && totalDist > u_turbulenceDist) {
                        // Set air pixel to be turbulent
                        u_airPixels[airI].turbulence.x = 1.0f;
                        // Don't need to write turbulence at air because it happens in move shader
                        // Write turbulence pixel half way between air and geometry
                        setScreenTurbulent((geoScreenPos + searchScreenPos) * 0.5f);

                        shouldSpawn = false;
                        break;
                    }

                    u_airGeoMap[airI] = geoI + 1;

                    shouldSpawn = false;
                    break;
                }
            }
        }
    }

    // Overwrite flag image with geometry index
    imageStore(u_flagImg, geoTexCoord, ivec4(geoI + 1, 0, 0, 0));

    // Make a new air pixel
    if (shouldSpawn) {
        int airI = atomicAdd(u_airCount, 1);
        if (airI >= u_maxAirPixels) {
            return;
        }

        u_airGeoMap[airI] = geoI + 1;

        vec2 airWindPos = geoWindPos;
        vec3 refl = reflect(vec3(0.0f, 0.0f, -1.0f), geoNormal);
        vec2 airVelocity = refl.xy * u_windSpeed;
        airVelocity *= u_initVelC;

        u_airPixels[airI].windPos = airWindPos;
        u_airPixels[airI].velocity = airVelocity;
        u_airPixels[airI].backforce = vec2(0.0f);
        u_airPixels[airI].turbulence = vec2(0.0f);

        // Draw to fbo to avoid another draw later, only necessary for seeing the results immediately
        if (k_debug) {
            uvec4 color = imageLoad(u_frontImg, geoTexCoord);
            color.g |= k_airBit;
            imageStore(u_frontImg, geoTexCoord, color);
        }
    }

    // Color active geo pixels more brightly
    if (k_debug && k_distinguishActivePixels) {
        uvec4 color = imageLoad(u_frontImg, geoTexCoord);
        color.r |= k_activeBit;
        imageStore(u_frontImg, geoTexCoord, color);
    }
}

// Move ------------------------------------------------------------------------

void move(int airI) {
    vec2 airWindPos = u_airPixels[airI].windPos;
    vec2 airVelocity = u_airPixels[airI].velocity;
    float airTurbulence = u_airPixels[airI].turbulence.x;
    int geoI = u_airGeoMap[airI];
    bool isGeo = false;
    if (geoI > 0) { --geoI; isGeo = true; }
    vec2 airScreenPos = windToScreen(airWindPos);

    bool shouldSearch = !isGeo;

    // Check if air pixel is within turbulence
    if (k_doTurbulence && isScreenTurbulent(airScreenPos)) {
        airTurbulence = 1.0f;
        u_airPixels[airI].turbulence.x = 1.0f;
    }
    // If air pixel is turbulent, write turbulence
    if (k_doTurbulence && airTurbulence > 0.0f) {
        setScreenTurbulent(airScreenPos);
        shouldSearch = false;
    }

    // If not turbulent and no geo found for this air, search for geo
    if (shouldSearch) {
        vec2 searchScreenPos = airScreenPos;
        ivec2 searchPixel = ivec2(searchScreenPos);

        vec2 searchDir = u_airPixels[airI].backforce.xy;
        if (searchDir != vec2(0.0f)) {
            searchDir = normalize(searchDir);
            vec2 corner = step(vec2(0.0f), searchDir);
            float totalDist = 0.0f;
            while (true) {
                // TODO: potentially optimize line search
                vec2 delta = corner - (searchScreenPos - vec2(searchPixel));
                vec2 dist = abs(delta / searchDir);
                if (dist.x < dist.y) {
                    searchScreenPos += searchDir * dist.x;
                    searchPixel.x += int(sign(searchDir.x));
                    totalDist += screenToWindDist(dist.x);
                }
                else {
                    searchScreenPos += searchDir * dist.y;
                    searchPixel.y += int(sign(searchDir.y));
                    totalDist += screenToWindDist(dist.y);
                }

                if (totalDist > u_maxSearchDist) {
                    break;
                }

                // If find turbulence, stop looking and mark turbulence
                if (k_doTurbulence && isScreenTurbulent(searchScreenPos)) {
                    // Mark air as turbulent
                    airTurbulence = 1.0f;
                    u_airPixels[airI].turbulence.x = 1.0f;
                    // Write turbulence at air
                    setScreenTurbulent(airScreenPos);
                    // Write turbulence pixel half way between found turbulence and air
                    setScreenTurbulent((airScreenPos + searchScreenPos) * 0.5f);
                    break;
                }

                uvec4 color = imageLoad(u_frontImg, searchPixel);

                // Visualize the search
                //if (k_debug) {
                //    imageStore(u_fboImg, pixel, vec4(color.r, color.g, 0.5f, color.a));
                //}

                if ((color.r & k_geoBit) != 0) { // we found a geo pixel
                    geoI = imageLoad(u_flagImg, searchPixel).x;
                    if (geoI > 0) { // TODO: this should not be necessary, just here for sanity
                        --geoI;
                        isGeo = true;

                        u_airGeoMap[airI] = geoI + 1;

                        if (k_doTurbulence && totalDist > u_turbulenceDist) {
                            // Set air pixel to be turbulent
                            airTurbulence = 1.0f;
                            u_airPixels[airI].turbulence.x = 1.0f;
                            // Write turbulence at air
                            setScreenTurbulent(airScreenPos);
                            // Write turbulence pixel at air and half way between air and geometry
                            setScreenTurbulent((airScreenPos + searchScreenPos) * 0.5f);
                        }
                    }

                    break;
                }
            }
        }
    }

    vec2 backforce = vec2(0.0f);
    vec3 lift = vec3(0.0f);
    vec3 torq = vec3(0.0f);

    // For each associated geo pixel, update backforce, lift, and drag
    if (isGeo) {
        vec2 geoWindPos = u_geoPixels[geoI].windPos;
        vec3 geoNormal = u_geoPixels[geoI].normal.xyz;
        float dist = distance(airWindPos, geoWindPos);

        float area = u_pixelSize * u_sliceSize * (1.0f - abs(dot(geoNormal, normalize(vec3(airVelocity, -u_windSpeed)))));

        // Calculate backforce
        vec2 thisBackforce = safeNormalize(-geoNormal.xy) * dist;// * dist;// = dist*dist*a + dist*b + c;
        thisBackforce *= u_backforceC;
        backforce += thisBackforce;

        // Calculate lift
        float liftFactor = 0.5f * k_airDensity * u_windSpeed * u_windSpeed * area;
        liftFactor *= dist / u_turbulenceDist;
        liftFactor *= u_liftC;
        if (airTurbulence > 0.0f) liftFactor = 0.0f;
        vec3 lift = geoNormal * liftFactor;

        // Calculate torque
        vec3 torq = cross(vec3(geoWindPos, u_sliceZ), lift);

        totalLift += lift;
        totalTorq += torq;
    }

    // Color active air pixels more brightly
    if (k_debug && k_distinguishActivePixels && isGeo) {
        ivec2 texCoord = ivec2(windToScreen(airWindPos));
        uvec4 color = imageLoad(u_frontImg, texCoord);
        color.r |= k_airBit | k_activeBit;
        imageStore(u_frontImg, texCoord, color);
    }

    // Update velocity
    airVelocity += backforce * u_dt;
    // Sweep back by diminishing xy components
    float factor;
    if (k_doWindShadow) {
        factor = mix(u_flowback, 1.0f, getScreenShadFactor(airScreenPos));
    }
    else {
        factor = u_flowback;
    }
    factor = pow(factor, u_sliceSize);
    airVelocity *= factor;

    // Update location
    airWindPos += airVelocity * u_dt;

    u_airPixels[airI].windPos = airWindPos;
    u_airPixels[airI].velocity = airVelocity;
    u_airPixels[airI].backforce = backforce;
    u_airPixels[airI].turbulence.x = airTurbulence;
}

// Main ------------------------------------------------------------------------

void main() {
    int workI = int(gl_LocalInvocationIndex);
    ivec2 workI2D = ivec2(workI % k_workGroupSize2D.x, workI / k_workGroupSize2D.x);
    s_accumulationArray[workI] = vec3(0.0f);

    // Zero results
    if (workI == 0) {
        u_results[u_slice].lift = vec4(0.0f);
        u_results[u_slice].drag = vec4(0.0f);
        u_results[u_slice].torq = vec4(0.0f);
    }

    // Prospect
    for (ivec2 texCoord = ivec2(0, workI2D.y); texCoord.y < u_screenSize; texCoord.y += k_workGroupSize2D.y) {
        for (texCoord.x = workI2D.x; texCoord.x < u_screenSize; texCoord.x += k_workGroupSize2D.x) {
            prospect(texCoord);
        }
    }

    barrier();

    // Copy turbulence textue to previous turbulence texture
    for (ivec2 texCoord = ivec2(0, workI2D.y); texCoord.y < u_screenSize / 4; texCoord.y += k_workGroupSize2D.y) {
        for (texCoord.x = workI2D.x; texCoord.x < u_screenSize / 4; texCoord.x += k_workGroupSize2D.x) {
            imageStore(u_prevTurbImg, texCoord, imageLoad(u_turbImg, texCoord));
        }
    }

    barrier();

    // Draw
    for (int prevAirI = workI; prevAirI < u_prevAirCount; prevAirI += k_workGroupSize) {
        draw(prevAirI);
    }

    barrier();

    // Outline
    for (int geoI = workI; geoI < u_geoCount; geoI += k_workGroupSize) {
        outline(geoI);
    }

    barrier();

    // Move
    for (int airI = workI; airI < u_airCount; airI += k_workGroupSize) {
        move(airI);
    }

    barrier();

    // Accumulate lift
    s_accumulationArray[workI] = totalLift;
    accumulate();
    if (workI == 0) u_results[u_slice].lift.xyz += s_accumulationArray[0];

    // Accumulate drag
    s_accumulationArray[workI] = totalDrag;
    accumulate();
    if (workI == 0) u_results[u_slice].drag.xyz += s_accumulationArray[0];

    // Accumulate torque
    s_accumulationArray[workI] = totalTorq;
    accumulate();
    if (workI == 0) u_results[u_slice].torq.xyz += s_accumulationArray[0];
}