#version 450 core

#define MAX_GEO_PER_AIR 3

#ifndef DEBUG
#define DEBUG false
#endif

#ifndef DO_WIND_SHADOW
#define DO_WIND_SHADOW false
#endif

#ifndef DO_TURBULENCE
#define DO_TURBULENCE false
#endif

#ifndef DISTINGUISH_ACTIVE_PIXELS
#define DISTINGUISH_ACTIVE_PIXELS false
#endif

layout (local_size_x = 1024, local_size_y = 1, local_size_z = 1) in;

// Types -----------------------------------------------------------------------

struct Result {
    vec4 lift;
    vec4 drag;
    vec4 torq;
};

struct GeoPixel {
    vec2 windPos;
    ivec2 texCoord;
    vec4 normal;
};

struct AirPixel {
    vec2 windPos;
    vec2 velocity;
    vec2 backforce;
    vec2 turbulence; // x component is turbulence
};

struct AirGeoMapElement {
    int geoCount;
    int geoIndices[MAX_GEO_PER_AIR];
};

// Constants -------------------------------------------------------------------

const uint k_workGroupSize = gl_WorkGroupSize.x * gl_WorkGroupSize.y * gl_WorkGroupSize.z;
const bool k_debug = DEBUG;
const float k_airDensity = 1.0f;
const bool k_doWindShadow = DO_WIND_SHADOW;
const bool k_distinguishActivePixels = DISTINGUISH_ACTIVE_PIXELS; // Makes certain "active" pixels brigher for visual clarity, but lowers performance
const float k_inactiveVal = k_distinguishActivePixels && k_debug ? 1.0f / 3.0f : 1.0f;
const int k_maxEdgeSeekSteps = 64; // Necessary in pathological cases where normals form a loop
const float k_minNormalZ = 1.0f / 1000000.0f;
const float k_maxNormalZ = 1.0f - k_minNormalZ;
const bool k_doTurbulence = DO_TURBULENCE;

// Uniforms --------------------------------------------------------------------

layout (binding = 0,        rgba8) uniform  image2D u_fboImg;
layout (binding = 1, rgba16_snorm) uniform  image2D u_fboNormImg;
layout (binding = 2,         r32i) uniform iimage2D u_flagImg;
layout (binding = 3,           r8) uniform  image2D u_turbImg;
layout (binding = 4,           r8) uniform  image2D u_prevTurbImg;
layout (binding = 5,           r8) uniform  image2D u_shadImg;

layout (binding = 1) uniform sampler2D u_prevTurbTex;
layout (binding = 2) uniform sampler2D u_shadTex;

// Uniform buffer for better read-only performance
layout (binding = 0, std140) uniform Constants {
    int u_maxGeoPixels;
    int u_maxAirPixels;
    int u_screenSize;
    float u_liftC;
    float u_dragC;
    float u_windframeSize;
    float u_windframeDepth;
    float u_sliceSize;
    float u_turbulenceDist;
    float u_maxSearchDist;
    float u_windShadDist;
    float u_backforceC;
    float u_flowback;
    float u_initVelC;
    float u_windSpeed;
    float u_dt;
    int u_slice;
    float u_sliceZ;
    float u_pixelSize;
};

layout (binding = 0, std430) restrict buffer GeoPixels {
    coherent int u_geoCount;
    int u_GeoPixels_pad0;
    int u_GeoPixels_pad1;
    int u_GeoPixels_pad2;
    GeoPixel u_geoPixels[];
};

layout (binding = 1, std430) restrict buffer AirPixels {
    int u_airCount;
    int u_AirPixels_pad0;
    int u_AirPixels_pad1;
    int u_AirPixels_pad2;
    AirPixel u_airPixels[];
};

layout (binding = 2, std430) restrict buffer PrevAirPixels {
    int u_prevAirCount;
    int u_PrevAirPixels_pad0;
    int u_PrevAirPixels_pad1;
    int u_PrevAirPixels_pad2;
    AirPixel u_prevAirPixels[];
};

layout (binding = 3, std430) restrict buffer AirGeoMap {
    coherent AirGeoMapElement u_airGeoMap[];
};

layout (binding = 4, std430) restrict buffer Results {
    Result u_results[];
};

// Shared ----------------------------------------------------------------------

shared vec3 s_accumulationArray[k_workGroupSize];

// Functions -------------------------------------------------------------------

vec2 windToScreen(vec2 wind) {
    return (wind / u_windframeSize + 0.5f) * float(u_screenSize);
}

vec2 screenToWind(vec2 screen) {
    return (screen / u_screenSize - 0.5f) * u_windframeSize;
}

float screenToWindDist(float screenDist) {
    return screenDist / float(u_screenSize) * u_windframeSize;
}

bool isScreenInShadow(vec2 screenPos) {
    return texture2D(u_shadTex, screenPos / u_screenSize).r > 0.0f;
}

bool isScreenTurbulent(vec2 screenPos) {
    return texture2D(u_prevTurbTex, screenPos / u_screenSize).r > 0.0f;
}

bool isWindTurbulent(vec2 windPos) {
    return isScreenTurbulent(windToScreen(windPos));
}

void setScreenTurbulent(vec2 screenPos) {
    imageStore(u_turbImg, ivec2(screenPos * 0.25f), vec4(1.0f, 0.0f, 0.0f, 0.0f));
}

void setWindTurbulent(vec2 windPos) {
    setScreenTurbulent(windToScreen(windPos));
}

float getShadFactor(float shad) {
    float shadDepth = shad * u_windframeDepth;
    float currDepth = u_slice * u_sliceSize;
    return float(shad != 0.0f) * max((1.0f - (currDepth - shadDepth) / u_windShadDist), 0.0f);
}

float getScreenShadFactor(vec2 screenPos) {
    return getShadFactor(texture2D(u_shadTex, screenPos / u_screenSize).r);
}

float getWindShadFactor(vec2 windPos) {
    return getScreenShadFactor(windToScreen(windPos));
}

// Returns one of <1, 0>, <-1, 0>, <0, 1>, <0, -1> corresponding to dir
ivec2 getPixelDelta(vec2 dir) {
    vec2 signs = sign(dir);
    vec2 mags = dir * signs;
    if (mags.y >= mags.x) {
        return ivec2(0, int(signs.y));
    }
    else {
        return ivec2(int(signs.x), 0);
    }
}

void accumulate() {
    uint workI = gl_LocalInvocationIndex;
    for (uint n = k_workGroupSize / 2; n > 0; n /= 2) {
        barrier();
        if (workI < n) s_accumulationArray[workI] += s_accumulationArray[workI + n];
    }
}

// Globals (per instance) ------------------------------------------------------

vec3 totalLift = vec3(0.0f);
vec3 totalDrag = vec3(0.0f);
vec3 totalTorq = vec3(0.0f);

// Prospect --------------------------------------------------------------------

void prospect(int workI, ivec2 texCoord) {
    // If not geometry, ignore
    vec4 color = imageLoad(u_fboImg, texCoord);
    if (color.r == 0.0f) {
        return;
    }

    imageStore(u_fboImg, texCoord, vec4(color.r, 0.0f, 0.0f, 0.0f));

    vec2 geoWindPos = screenToWind(vec2(texCoord) + color.gb);
    vec3 geoNormal = imageLoad(u_fboNormImg, texCoord).xyz;

    // Set wind shadow
    if (k_doWindShadow && geoNormal.z < 0.0f) { // TODO: do we want a minimum angle for wind shadow?
        imageStore(u_shadImg, texCoord / 4, vec4(u_slice * u_sliceSize / u_windframeDepth, 0.0f, 0.0f, 0.0f));
    }
    // Calculate drag and torque
    else if (!isScreenInShadow(vec2(texCoord) + 0.5f)) {
        float dragFactor = 0.5f * k_airDensity * u_windSpeed * u_windSpeed * u_pixelSize * u_pixelSize * geoNormal.z;
        dragFactor *= u_dragC;
        vec3 drag = -geoNormal * dragFactor;
        totalDrag += drag;

        vec3 torq = cross(vec3(geoWindPos, u_sliceZ), drag); // TODO: is this right
        totalTorq += torq;
    }

    ivec2 nextTexCoord = texCoord + getPixelDelta(geoNormal.xy);
    vec4 nextColor = imageLoad(u_fboImg, nextTexCoord);
    if (nextColor.r != 0.0f) {
        return;
    }

    int geoI = atomicAdd(u_geoCount, 1);
    if (geoI >= u_maxGeoPixels) {
        return;
    }

    u_geoPixels[geoI].windPos = geoWindPos.xy;
    u_geoPixels[geoI].normal = vec4(geoNormal, 0.0f);
    u_geoPixels[geoI].texCoord = texCoord;
}

// Draw ------------------------------------------------------------------------

void draw(int prevAirI) {
    AirPixel air = u_prevAirPixels[prevAirI];
    ivec2 airTexCoord = ivec2(windToScreen(air.windPos));

    // Check if in texture
    if (airTexCoord.x < 0 || airTexCoord.y < 0 || airTexCoord.x >= u_screenSize || airTexCoord.y >= u_screenSize) {
        return;
    }

    vec4 color = imageLoad(u_fboImg, airTexCoord);

    // If in geometry, follow the geo normals to find the edge
    if (color.r != 0.0f) {
        ivec2 pixel = airTexCoord;
        int steps = 0;
        while (true) {
            vec3 geoNormal = imageLoad(u_fboNormImg, airTexCoord).xyz;
            if (abs(geoNormal.z) > k_maxNormalZ) {
                return;
            }
            ivec2 nextPixel = pixel + getPixelDelta(geoNormal.xy);
            vec4 nextColor = imageLoad(u_fboImg, nextPixel);

            // We found the edge, move air to it
            if (nextColor.r == 0.0f) {
                airTexCoord = pixel;

                //vec3 tangentVel = cross(geoNormal, cross(geoNormal, vec3(0.0f, 0.0f, 1.0f))); // TODO
                //vec2 tangentVel = geoNormal.xy * geoNormal.z; // Equivalent to above
                //tangentVel = tangentVel * u_windSpeed;

                vec2 norm = normalize(geoNormal.xy);
                if (geoNormal.z > 0.0f) {
                    air.velocity = max(dot(air.velocity, norm), geoNormal.z * u_windSpeed) * norm;
                }
                else {
                    air.velocity = geoNormal.z * u_windSpeed * norm;
                }

                air.backforce = vec2(0.0f);
                air.turbulence = vec2(0.0f);
                break;
            }

            // If air "inside" geometry, get rid of it, unless it's on the very edge
            if (geoNormal.z < 0.0f) {
                return;
            }

            // TODO: position here instead
            air.windPos = vec2(0.0f); // Signify to outline shader that this air has been adjusted and needs properly positioned

            pixel = nextPixel;
            color = nextColor;
            if (++steps >= k_maxEdgeSeekSteps) {
                return;
            }
        }
    }

    // air.windPos now invalid if there was edge seek

    // Air already exists at pixel
    if (color.g != 0.0f) {
        return;
    }

    // Move to current air pixel buffer
    int airI = atomicAdd(u_airCount, 1);
    if (airI >= u_maxAirPixels) {
        return;
    }
    u_airPixels[airI] = air;
    u_airGeoMap[airI].geoCount = 0; // This air pixel is not yet associated with any geometry

    // Store air index
    imageStore(u_flagImg, airTexCoord, ivec4(airI + 1, 0, 0, 0));

    // Draw to front view
    color.g = k_inactiveVal;
    imageStore(u_fboImg, airTexCoord, color);
}

// Outline ---------------------------------------------------------------------

void outline(int geoI) {
    vec2 geoWindPos = u_geoPixels[geoI].windPos;
    vec3 geoNormal = u_geoPixels[geoI].normal.xyz;
    ivec2 geoTexCoord = u_geoPixels[geoI].texCoord; // Need exact texture coord because rasterization math and our wind-to-screen math don't always align
    vec2 geoScreenPos = windToScreen(geoWindPos);
    geoScreenPos = clamp(geoScreenPos, vec2(geoTexCoord), vec2(geoTexCoord + 1)); // necessary for edge cases

    bool shouldSpawn = geoNormal.z >= k_minNormalZ && geoNormal.z <= k_maxNormalZ;
    bool shouldSearch = true;

    // If geo is in turbulence, forget it
    if (k_doTurbulence && isScreenTurbulent(geoScreenPos)) {
        shouldSearch = false;
        shouldSpawn = false;
    }

    // Look for existing air pixel
    if (shouldSearch) {
        vec2 searchScreenPos = geoScreenPos;
        ivec2 searchPixel = geoTexCoord;
        vec2 searchDir = normalize(geoNormal.xy);
        vec2 corner = step(vec2(0.0f), searchDir);
        float totalDist = 0.0f;

        // Check for air on geometry
        vec4 color = imageLoad(u_fboImg, searchPixel);
        if (color.g != 0.0f) {
            int airI = imageLoad(u_flagImg, searchPixel).x;
            if (airI != 0) { // TODO: this should not be necessary, just here for sanity
                --airI;

                shouldSpawn = false;

                if (u_airPixels[airI].windPos == vec2(0.0f)) u_airPixels[airI].windPos = geoWindPos; // TODO: get rid of this

                int mapI = atomicAdd(u_airGeoMap[airI].geoCount, 1);
                if (mapI < MAX_GEO_PER_AIR) {
                    u_airGeoMap[airI].geoIndices[mapI] = geoI;
                }
            }
        }

        // Search along line in direction of geo normal
        if (shouldSpawn)
        while (true) {
            // TODO: potentially optimize line search
            vec2 delta = corner - (searchScreenPos - vec2(searchPixel));
            vec2 dist = abs(delta / searchDir);
            if (dist.x < dist.y) {
                searchScreenPos += searchDir * dist.x;
                searchPixel.x += int(sign(searchDir.x));
                totalDist += screenToWindDist(dist.x);
            }
            else {
                searchScreenPos += searchDir * dist.y;
                searchPixel.y += int(sign(searchDir.y));
                totalDist += screenToWindDist(dist.y);
            }

            if (totalDist > u_maxSearchDist) {
                break;
            }

            // If find turbulence, stop looking and mark turbulence
            if (k_doTurbulence && isScreenTurbulent(searchScreenPos)) {
                // Write turbulence pixel half way between found turbulence and geometry
                setScreenTurbulent((geoScreenPos + searchScreenPos) * 0.5f);

                shouldSpawn = false;
                break;
            }

            color = imageLoad(u_fboImg, searchPixel);

            // Visualize the search
            //if (k_debug) {
            //    imageStore(u_fboImg, pixel, vec4(color.r, color.g, 0.5f, color.a));
            //}

            if (color.r != 0.0f) { // we found a geo pixel
                break;
            }
            if (color.g != 0.0f) { // we found an air pixel
                int airI = imageLoad(u_flagImg, searchPixel).x;
                if (airI != 0) { // TODO: this should not be necessary, just here for sanity
                    --airI;

                    // If past turbulence distance, set air as turbulent and mark turbulance
                    if (k_doTurbulence && totalDist > u_turbulenceDist) {
                        // Set air pixel to be turbulent
                        u_airPixels[airI].turbulence.x = 1.0f;
                        // Don't need to write turbulence at air because it happens in move shader
                        // Write turbulence pixel half way between air and geometry
                        setScreenTurbulent((geoScreenPos + searchScreenPos) * 0.5f);

                        shouldSpawn = false;
                        break;
                    }

                    int mapI = atomicAdd(u_airGeoMap[airI].geoCount, 1);
                    if (mapI >= MAX_GEO_PER_AIR) {
                        break;
                    }
                    u_airGeoMap[airI].geoIndices[mapI] = geoI;

                    shouldSpawn = false;
                    break;
                }
            }
        }
    }

    // Overwrite flag image with geometry index
    imageStore(u_flagImg, geoTexCoord, ivec4(geoI + 1, 0, 0, 0));

    // Make a new air pixel
    if (shouldSpawn) {
        int airI = atomicAdd(u_airCount, 1);
        if (airI >= u_maxAirPixels) {
            return;
        }

        u_airGeoMap[airI].geoCount = 1;
        u_airGeoMap[airI].geoIndices[0] = geoI;

        vec2 airWindPos = geoWindPos;
        vec3 refl = reflect(vec3(0.0f, 0.0f, -1.0f), geoNormal);
        vec2 airVelocity = refl.xy * u_windSpeed;
        airVelocity *= u_initVelC;

        u_airPixels[airI].windPos = airWindPos;
        u_airPixels[airI].velocity = airVelocity;
        u_airPixels[airI].backforce = vec2(0.0f);
        u_airPixels[airI].turbulence = vec2(0.0f);

        // Draw to fbo to avoid another draw later, only necessary for seeing the results immediately
        if (k_debug) {
            vec4 color = imageLoad(u_fboImg, geoTexCoord);
            color.g = k_inactiveVal;
            imageStore(u_fboImg, geoTexCoord, color);
        }
    }

    // Color active geo pixels more brightly
    if (k_debug && k_distinguishActivePixels) {
        vec4 color = imageLoad(u_fboImg, geoTexCoord);
        color.r = 1.0f;
        imageStore(u_fboImg, geoTexCoord, color);
    }
}

// Move ------------------------------------------------------------------------

void move(int airI) {
    vec2 airWindPos = u_airPixels[airI].windPos;
    vec2 airVelocity = u_airPixels[airI].velocity;
    float airTurbulence = u_airPixels[airI].turbulence.x;
    int geoCount = u_airGeoMap[airI].geoCount;
    vec2 airScreenPos = windToScreen(airWindPos);

    bool shouldSearch = geoCount == 0;

    // Check if air pixel is within turbulence
    if (k_doTurbulence && isScreenTurbulent(airScreenPos)) {
        airTurbulence = 1.0f;
        u_airPixels[airI].turbulence.x = 1.0f;
    }
    // If air pixel is turbulent, write turbulence
    if (k_doTurbulence && airTurbulence > 0.0f) {
        setScreenTurbulent(airScreenPos);
        shouldSearch = false;
    }

    // If not turbulent and no geo found for this air, search for geo
    if (shouldSearch) {
        vec2 searchScreenPos = airScreenPos;
        ivec2 searchPixel = ivec2(searchScreenPos);

        vec2 searchDir = u_airPixels[airI].backforce.xy;
        if (searchDir != vec2(0.0f)) {
            searchDir = normalize(searchDir);
            vec2 corner = step(vec2(0.0f), searchDir);
            float totalDist = 0.0f;
            while (true) {
                // TODO: potentially optimize line search
                vec2 delta = corner - (searchScreenPos - vec2(searchPixel));
                vec2 dist = abs(delta / searchDir);
                if (dist.x < dist.y) {
                    searchScreenPos += searchDir * dist.x;
                    searchPixel.x += int(sign(searchDir.x));
                    totalDist += screenToWindDist(dist.x);
                }
                else {
                    searchScreenPos += searchDir * dist.y;
                    searchPixel.y += int(sign(searchDir.y));
                    totalDist += screenToWindDist(dist.y);
                }

                if (totalDist > u_maxSearchDist) {
                    break;
                }

                // If find turbulence, stop looking and mark turbulence
                if (k_doTurbulence && isScreenTurbulent(searchScreenPos)) {
                    // Mark air as turbulent
                    airTurbulence = 1.0f;
                    u_airPixels[airI].turbulence.x = 1.0f;
                    // Write turbulence at air
                    setScreenTurbulent(airScreenPos);
                    // Write turbulence pixel half way between found turbulence and air
                    setScreenTurbulent((airScreenPos + searchScreenPos) * 0.5f);
                    break;
                }

                vec4 color = imageLoad(u_fboImg, searchPixel);

                // Visualize the search
                //if (k_debug) {
                //    imageStore(u_fboImg, pixel, vec4(color.r, color.g, 0.5f, color.a));
                //}

                if (color.r != 0.0f) { // we found a geo pixel
                    int geoI = imageLoad(u_flagImg, searchPixel).x;
                    if (geoI != 0) { // TODO: this should not be necessary, just here for sanity
                        --geoI;

                        ++geoCount;
                        ++u_airGeoMap[airI].geoCount;
                        u_airGeoMap[airI].geoIndices[0] = geoI;

                        if (k_doTurbulence && totalDist > u_turbulenceDist) {
                            // Set air pixel to be turbulent
                            airTurbulence = 1.0f;
                            u_airPixels[airI].turbulence.x = 1.0f;
                            // Write turbulence at air
                            setScreenTurbulent(airScreenPos);
                            // Write turbulence pixel at air and half way between air and geometry
                            setScreenTurbulent((airScreenPos + searchScreenPos) * 0.5f);
                        }
                    }

                    break;
                }
            }
        }
    }

    vec2 backforce = vec2(0.0f);
    vec3 lift = vec3(0.0f);
    vec3 torq = vec3(0.0f);

    // For each associated geo pixel, update backforce, lift, and drag
    for (int mapI = 0; mapI < geoCount; ++mapI) {
        int geoI = u_airGeoMap[airI].geoIndices[mapI];
        vec2 geoWindPos = u_geoPixels[geoI].windPos;
        vec3 geoNormal = u_geoPixels[geoI].normal.xyz;
        float dist = distance(airWindPos, geoWindPos);

        float area = u_pixelSize * u_sliceSize * (1.0f - abs(dot(geoNormal, normalize(vec3(airVelocity, -u_windSpeed)))));

        // Calculate backforce
        vec2 thisBackforce = normalize(-geoNormal.xy) * dist;// * dist;// = dist*dist*a + dist*b + c;
        thisBackforce *= u_backforceC;
        backforce += thisBackforce;

        // Calculate lift
        float liftFactor = 0.5f * k_airDensity * u_windSpeed * u_windSpeed * area;
        liftFactor *= dist / u_turbulenceDist;
        liftFactor *= u_liftC;
        if (airTurbulence > 0.0f) liftFactor = 0.0f;
        vec3 thisLift = geoNormal * liftFactor;

        // Calculate torque
        vec3 thisTorq = cross(vec3(geoWindPos, u_sliceZ), thisLift);

        lift += thisLift;
        torq += thisTorq;
    }
    // Average
    if (geoCount > 0) {
        float invGeoCount = 1.0f / float(geoCount);
        backforce *= invGeoCount;
    }
    // Add to total
    totalLift += lift;
    totalTorq += torq;

    // Color active air pixels more brightly
    if (k_debug && k_distinguishActivePixels && geoCount > 0) {
        ivec2 texCoord = ivec2(windToScreen(airWindPos));
        vec4 color = imageLoad(u_fboImg, texCoord);
        color.g = 1.0f;
        imageStore(u_fboImg, texCoord, color);
    }

    // Update velocity
    airVelocity += backforce * u_dt;
    // Sweep back by diminishing xy components
    float factor;
    if (k_doWindShadow) {
        factor = mix(u_flowback, 1.0f, getScreenShadFactor(airScreenPos));
    }
    else {
        factor = u_flowback;
    }
    factor = pow(factor, u_sliceSize);
    airVelocity *= factor;

    // Update location
    airWindPos += airVelocity * u_dt;

    u_airPixels[airI].windPos = airWindPos;
    u_airPixels[airI].velocity = airVelocity;
    u_airPixels[airI].backforce = backforce;
    u_airPixels[airI].turbulence.x = airTurbulence;
}

// Main ------------------------------------------------------------------------

void main() {
    int workI = int(gl_LocalInvocationIndex);
    ivec2 workCoord = ivec2(workI % 32, workI / 32); // TODO: magic
    s_accumulationArray[workI] = vec3(0.0f);

    // Zero results
    if (workI == 0) {
        u_results[u_slice].lift = vec4(0.0f);
        u_results[u_slice].drag = vec4(0.0f);
        u_results[u_slice].torq = vec4(0.0f);
    }
        
    // Prospect
    for (ivec2 texCoord = ivec2(0, workCoord.y); texCoord.y < u_screenSize; texCoord.y += 32) { // TODO: magic
        for (texCoord.x = workCoord.x; texCoord.x < u_screenSize; texCoord.x += 32) { // TODO: magic
            prospect(workI, texCoord);
        }
    }

    barrier();

    // Copy turbulence textue to previous turbulence texture
    for (ivec2 texCoord = ivec2(0, workCoord.y); texCoord.y < u_screenSize / 4; texCoord.y += 32) { // TODO: magic
        for (texCoord.x = workCoord.x; texCoord.x < u_screenSize / 4; texCoord.x += 32) { // TODO: magic
            imageStore(u_prevTurbImg, texCoord, imageLoad(u_turbImg, texCoord));
        }
    }

    barrier();

    // Draw
    for (int prevAirI = workI; prevAirI < u_prevAirCount; prevAirI += int(k_workGroupSize)) {
        draw(prevAirI);
    }

    barrier();

    // Outline
    for (int geoI = workI; geoI < u_geoCount; geoI += int(k_workGroupSize)) {
        outline(geoI);
    }

    barrier();

    // Move
    for (int airI = workI; airI < u_airCount; airI += int(k_workGroupSize)) {
        move(airI);
    }

    barrier();

    // Accumulate lift
    s_accumulationArray[workI] = totalLift;
    accumulate();
    if (workI == 0) u_results[u_slice].lift.xyz += s_accumulationArray[0];

    // Accumulate drag
    s_accumulationArray[workI] = totalDrag;
    accumulate();
    if (workI == 0) u_results[u_slice].drag.xyz += s_accumulationArray[0];

    // Accumulate torque
    s_accumulationArray[workI] = totalTorq;
    accumulate();
    if (workI == 0) u_results[u_slice].torq.xyz += s_accumulationArray[0];
}