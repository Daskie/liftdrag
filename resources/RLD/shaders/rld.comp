#version 450 core

#extension GL_NV_shader_atomic_float : enable

layout (local_size_x = WORK_GROUP_SIZE, local_size_y = 1, local_size_z = 1) in;

// Types -----------------------------------------------------------------------

struct Result {
    vec4 lift;
    vec4 drag;
    vec4 torq;
};

struct GeoPixel {
    vec2 windPos;
    ivec2 texCoord;
    vec4 normal;
};

struct AirPixel {
    vec2 windPos;
    vec2 velocity;
    vec2 backforce;
    vec2 turbulence; // x component is turbulence
};

struct SoftVertex {
    vec3 position;
    float mass;
    vec3 normal;
    int group;
    vec3 prevPosition;
    float _0;
    vec3 force0; // lift
    float _1;
    vec3 force1; // drag
    float _2;
};

// Constants -------------------------------------------------------------------

// External
const bool k_debug = DEBUG;
const bool k_doWindShadow = DO_WIND_SHADOW;
const bool k_distinguishActivePixels = DISTINGUISH_ACTIVE_PIXELS; // Makes certain "active" pixels brigher for visual clarity, but lowers performance
const bool k_doTurbulence = DO_TURBULENCE;
const bool k_doCloth = DO_CLOTH;

const int k_workGroupSize = int(gl_WorkGroupSize.x * gl_WorkGroupSize.y * gl_WorkGroupSize.z);
const uint k_geoBit = 1, k_airBit = 2, k_activeBit = 4;
const float k_airDensity = 1.0f;
const float k_inactiveVal = k_distinguishActivePixels && k_debug ? 1.0f / 3.0f : 1.0f;
const int k_maxEdgeSeekSteps = 64; // Necessary in pathological cases where normals form a loop
const float k_minNormalZ = 1.0f / 1000000.0f;
const float k_maxNormalZ = 1.0f - k_minNormalZ;

// Uniforms --------------------------------------------------------------------

layout (binding = 0,      rgba8ui) uniform restrict uimage2D u_frontImg;
layout (binding = 1, rgba16_snorm) uniform restrict  image2D u_fboNormImg;
layout (binding = 2,         r32i) uniform restrict iimage2D u_flagImg;
layout (binding = 3,           r8) uniform restrict  image2D u_turbImg;
layout (binding = 4,           r8) uniform restrict  image2D u_prevTurbImg;
layout (binding = 5,           r8) uniform restrict  image2D u_shadImg;
layout (binding = 6,        r32ui) uniform restrict uimage2D u_indexImg;

layout (binding = 1) uniform sampler2D u_prevTurbTex;
layout (binding = 2) uniform sampler2D u_shadTex;

// Uniform buffer for better read-only performance
layout (binding = 0, std140) uniform Constants {
    int u_maxGeoPixels;
    int u_maxAirPixels;
    int u_screenSize;
    float u_liftC;
    float u_dragC;
    float u_windframeSize;
    float u_windframeDepth;
    float u_sliceSize;
    float u_turbulenceDist;
    float u_maxSearchDist;
    float u_windShadDist;
    float u_backforceC;
    float u_flowback;
    float u_initVelC;
    float u_windSpeed;
    float u_dt;
    int u_slice;
    float u_sliceZ;
    float u_pixelSize;
};

layout (binding = 0, std430) restrict buffer GeoPixels {
    coherent int u_geoCount;
    int u_GeoPixels_pad0;
    int u_GeoPixels_pad1;
    int u_GeoPixels_pad2;
    GeoPixel u_geoPixels[];
};

layout (binding = 1, std430) restrict buffer AirPixels {
    int u_airCount;
    int u_AirPixels_pad0;
    int u_AirPixels_pad1;
    int u_AirPixels_pad2;
    AirPixel u_airPixels[];
};

layout (binding = 2, std430) restrict buffer PrevAirPixels {
    int u_prevAirCount;
    int u_PrevAirPixels_pad0;
    int u_PrevAirPixels_pad1;
    int u_PrevAirPixels_pad2;
    AirPixel u_prevAirPixels[];
};

layout (binding = 3, std430) restrict buffer AirGeoMap {
    int u_airGeoMap[];
};

layout (binding = 4, std430) restrict buffer Results {
    Result u_results[];
};

// Only present if doing cloth
layout (binding = 5, std430) restrict buffer SoftVertices {
    SoftVertex u_softVertices[];
};

// Only present if doing cloth
layout (binding = 6, std430) restrict buffer Indices {
    uint u_indices[];
};

// Shared ----------------------------------------------------------------------

shared vec3 s_accumulationArray[k_workGroupSize];
shared int s_geoCounts[k_workGroupSize];

// Invocation variables --------------------------------------------------------

vec3 i_lift = vec3(0.0f);
vec3 i_drag = vec3(0.0f);
vec3 i_torq = vec3(0.0f);

// Functions -------------------------------------------------------------------

vec2 safeNormalize(vec2 v) {
    float d = dot(v, v);
    return d > 0.0f ? v / sqrt(d) : vec2(0.0f);
}

vec3 safeNormalize(vec3 v) {
    float d = dot(v, v);
    return d > 0.0f ? v / sqrt(d) : vec3(0.0f);
}

bool isInTexture(ivec2 p, ivec2 texSize) {
    return all(bvec4(greaterThanEqual(p, ivec2(0)), lessThan(p, texSize)));
}

vec2 windToScreen(vec2 wind) {
    return (wind / u_windframeSize + 0.5f) * float(u_screenSize);
}

vec2 screenToWind(vec2 screen) {
    return (screen / u_screenSize - 0.5f) * u_windframeSize;
}

float screenToWindDist(float screenDist) {
    return screenDist / float(u_screenSize) * u_windframeSize;
}

bool isScreenInShadow(vec2 screenPos) {
    return texture2D(u_shadTex, screenPos / u_screenSize).r > 0.0f;
}

bool isScreenTurbulent(vec2 screenPos) {
    return texture2D(u_prevTurbTex, screenPos / u_screenSize).r > 0.0f;
}

bool isWindTurbulent(vec2 windPos) {
    return isScreenTurbulent(windToScreen(windPos));
}

void setScreenTurbulent(vec2 screenPos) {
    imageStore(u_turbImg, ivec2(screenPos * 0.25f), vec4(1.0f, 0.0f, 0.0f, 0.0f));
}

void setWindTurbulent(vec2 windPos) {
    setScreenTurbulent(windToScreen(windPos));
}

float getShadFactor(float shad) {
    float shadDepth = shad * u_windframeDepth;
    float currDepth = u_slice * u_sliceSize;
    return float(shad != 0.0f) * max((1.0f - (currDepth - shadDepth) / u_windShadDist), 0.0f);
}

float getScreenShadFactor(vec2 screenPos) {
    return getShadFactor(texture2D(u_shadTex, screenPos / u_screenSize).r);
}

float getWindShadFactor(vec2 windPos) {
    return getScreenShadFactor(windToScreen(windPos));
}

// Returns one of <1, 0>, <-1, 0>, <0, 1>, <0, -1> corresponding to dir
ivec2 getPixelDelta(vec2 dir) {
    vec2 signs = sign(dir);
    vec2 mags = dir * signs;
    if (mags.y >= mags.x) {
        return ivec2(0, int(signs.y));
    }
    else {
        return ivec2(int(signs.x), 0);
    }
}

void accumulate() {
    int workI = int(gl_LocalInvocationIndex);
    for (int n = k_workGroupSize / 2; n > 0; n /= 2) {
        barrier();
        if (workI < n) s_accumulationArray[workI] += s_accumulationArray[workI + n];
    }
}

void applySoftForce(ivec2 texCoord, vec3 lift, vec3 drag) {
    uint ii = imageLoad(u_indexImg, texCoord).x * 3;
    if (ii == 0) {
        return;
    }
    --ii;
    lift *= (1.0f / 3.0f);
    drag *= (1.0f / 3.0f);
    uint i0 = u_indices[ii + 0];
    uint i1 = u_indices[ii + 1];
    uint i2 = u_indices[ii + 2];
    if (lift != vec3(0.0f)) {
        atomicAdd(u_softVertices[i0].force0.x, lift.x);
        atomicAdd(u_softVertices[i0].force0.y, lift.y);
        atomicAdd(u_softVertices[i0].force0.z, lift.z);
        atomicAdd(u_softVertices[i1].force0.x, lift.x);
        atomicAdd(u_softVertices[i1].force0.y, lift.y);
        atomicAdd(u_softVertices[i1].force0.z, lift.z);
        atomicAdd(u_softVertices[i2].force0.x, lift.x);
        atomicAdd(u_softVertices[i2].force0.y, lift.y);
        atomicAdd(u_softVertices[i2].force0.z, lift.z);
    }
    if (drag != vec3(0.0f)) {
        atomicAdd(u_softVertices[i0].force1.x, drag.x);
        atomicAdd(u_softVertices[i0].force1.y, drag.y);
        atomicAdd(u_softVertices[i0].force1.z, drag.z);
        atomicAdd(u_softVertices[i1].force1.x, drag.x);
        atomicAdd(u_softVertices[i1].force1.y, drag.y);
        atomicAdd(u_softVertices[i1].force1.z, drag.z);
        atomicAdd(u_softVertices[i2].force1.x, drag.x);
        atomicAdd(u_softVertices[i2].force1.y, drag.y);
        atomicAdd(u_softVertices[i2].force1.z, drag.z);
    }
}

// Move ------------------------------------------------------------------------

void move(int airI) {
    vec2 airWindPos = u_airPixels[airI].windPos;
    vec2 airVelocity = u_airPixels[airI].velocity;
    float airTurbulence = u_airPixels[airI].turbulence.x;
    int geoI = u_airGeoMap[airI];
    bool isGeo = false;
    if (geoI > 0) { --geoI; isGeo = true; }
    vec2 airScreenPos = windToScreen(airWindPos);

    bool shouldSearch = !isGeo;

    // Check if air pixel is within turbulence
    if (k_doTurbulence && isScreenTurbulent(airScreenPos)) {
        airTurbulence = 1.0f;
        u_airPixels[airI].turbulence.x = 1.0f;
    }
    // If air pixel is turbulent, write turbulence
    if (k_doTurbulence && airTurbulence > 0.0f) {
        setScreenTurbulent(airScreenPos);
        shouldSearch = false;
    }

    // If not turbulent and no geo found for this air, search for geo
    if (shouldSearch) {
        vec2 searchScreenPos = airScreenPos;
        ivec2 searchPixel = ivec2(searchScreenPos);

        vec2 searchDir = u_airPixels[airI].backforce.xy;
        if (searchDir != vec2(0.0f)) {
            searchDir = normalize(searchDir);
            vec2 corner = step(vec2(0.0f), searchDir);
            float totalDist = 0.0f;
            while (true) {
                // TODO: potentially optimize line search
                vec2 delta = corner - (searchScreenPos - vec2(searchPixel));
                vec2 dist = abs(delta / searchDir);
                if (dist.x < dist.y) {
                    searchScreenPos += searchDir * dist.x;
                    searchPixel.x += int(sign(searchDir.x));
                    totalDist += screenToWindDist(dist.x);
                }
                else {
                    searchScreenPos += searchDir * dist.y;
                    searchPixel.y += int(sign(searchDir.y));
                    totalDist += screenToWindDist(dist.y);
                }

                if (totalDist > u_maxSearchDist) {
                    break;
                }

                // If find turbulence, stop looking and mark turbulence
                if (k_doTurbulence && isScreenTurbulent(searchScreenPos)) {
                    // Mark air as turbulent
                    airTurbulence = 1.0f;
                    u_airPixels[airI].turbulence.x = 1.0f;
                    // Write turbulence at air
                    setScreenTurbulent(airScreenPos);
                    // Write turbulence pixel half way between found turbulence and air
                    setScreenTurbulent((airScreenPos + searchScreenPos) * 0.5f);
                    break;
                }

                uvec4 color = imageLoad(u_frontImg, searchPixel);

                // Visualize the search
                //if (k_debug) {
                //    imageStore(u_fboImg, pixel, vec4(color.r, color.g, 0.5f, color.a));
                //}

                if ((color.r & k_geoBit) != 0) { // we found a geo pixel
                    geoI = imageLoad(u_flagImg, searchPixel).x;
                    if (geoI > 0) { // TODO: this should not be necessary, just here for sanity
                        --geoI;
                        isGeo = true;

                        u_airGeoMap[airI] = geoI + 1;

                        if (k_doTurbulence && totalDist > u_turbulenceDist) {
                            // Set air pixel to be turbulent
                            airTurbulence = 1.0f;
                            u_airPixels[airI].turbulence.x = 1.0f;
                            // Write turbulence at air
                            setScreenTurbulent(airScreenPos);
                            // Write turbulence pixel at air and half way between air and geometry
                            setScreenTurbulent((airScreenPos + searchScreenPos) * 0.5f);
                        }
                    }

                    break;
                }
            }
        }
    }

    vec2 backforce = vec2(0.0f);
    vec3 lift = vec3(0.0f);
    vec3 torq = vec3(0.0f);

    // For each associated geo pixel, update backforce, lift, and drag
    if (isGeo) {
        vec2 geoWindPos = u_geoPixels[geoI].windPos;
        vec3 geoNormal = u_geoPixels[geoI].normal.xyz;
        float dist = distance(airWindPos, geoWindPos);

        float area = u_pixelSize * u_sliceSize * (1.0f - abs(dot(geoNormal, normalize(vec3(airVelocity, -u_windSpeed)))));

        // Calculate backforce
        vec2 thisBackforce = safeNormalize(-geoNormal.xy) * dist;// * dist;// = dist*dist*a + dist*b + c;
        thisBackforce *= u_backforceC;
        backforce += thisBackforce;

        // Calculate lift
        float liftFactor = 0.5f * k_airDensity * u_windSpeed * u_windSpeed * area;
        liftFactor *= dist / u_turbulenceDist;
        liftFactor *= u_liftC;
        if (airTurbulence > 0.0f) liftFactor = 0.0f;
        vec3 lift = geoNormal * liftFactor;
        if (k_doCloth) {
            // If cloth, air could be on "wrong" side of geometry
            lift *= sign(dot(airWindPos - geoWindPos, geoNormal.xy));
        }

        // Calculate torque
        vec3 torq = cross(vec3(geoWindPos, u_sliceZ), lift);

        if (k_doCloth) {
            applySoftForce(ivec2(windToScreen(geoWindPos)), lift, vec3(0.0f));
        }
        else {
            i_lift += lift;
            i_torq += torq;
        }
    }

    // Color active air pixels more brightly
    if (k_debug && k_distinguishActivePixels && isGeo) {
        ivec2 texCoord = ivec2(windToScreen(airWindPos));
        uvec4 color = imageLoad(u_frontImg, texCoord);
        color.r |= k_airBit | k_activeBit;
        imageStore(u_frontImg, texCoord, color);
    }

    // Update velocity
    airVelocity += backforce * u_dt;
    // Sweep back by diminishing xy components
    float factor;
    if (k_doWindShadow) {
        factor = mix(u_flowback, 1.0f, getScreenShadFactor(airScreenPos));
    }
    else {
        factor = u_flowback;
    }
    factor = pow(factor, u_sliceSize);
    airVelocity *= factor;

    // Update location
    airWindPos += airVelocity * u_dt;

    u_airPixels[airI].windPos = airWindPos;
    u_airPixels[airI].velocity = airVelocity;
    u_airPixels[airI].backforce = backforce;
    u_airPixels[airI].turbulence.x = airTurbulence;
}

// Main ------------------------------------------------------------------------

void main() {
    int workI = int(gl_LocalInvocationIndex);

    // Zero accumulation array
    if (!k_doCloth) {
        s_accumulationArray[workI] = vec3(0.0f);
    }

    // Move
    for (int airI = workI; airI < u_airCount; airI += k_workGroupSize) {
        move(airI);
    }

    barrier();

    // Accumulate and save results
    if (!k_doCloth) {
        // Accumulate lift
        s_accumulationArray[workI] = i_lift;
        accumulate();
        if (workI == 0) u_results[u_slice].lift.xyz += s_accumulationArray[0];

        // Accumulate drag
        s_accumulationArray[workI] = i_drag;
        accumulate();
        if (workI == 0) u_results[u_slice].drag.xyz += s_accumulationArray[0];

        // Accumulate torque
        s_accumulationArray[workI] = i_torq;
        accumulate();
        if (workI == 0) u_results[u_slice].torq.xyz += s_accumulationArray[0];
    }
}