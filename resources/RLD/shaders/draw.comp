#version 450 core

#define MAX_GEO_PER_AIR 3

#ifndef DEBUG
#define DEBUG false
#endif

#ifndef DISTINGUISH_ACTIVE_PIXELS
#define DISTINGUISH_ACTIVE_PIXELS false
#endif

layout (local_size_x = 1024, local_size_y = 1, local_size_z = 1) in;

// Types -----------------------------------------------------------------------

struct Result {
    vec4 lift;
    vec4 drag;
    vec4 torq;
};

struct GeoPixel {
    vec2 windPos;
    ivec2 texCoord;
    vec4 normal;
};

struct AirPixel {
    vec2 windPos;
    vec2 velocity;
    vec2 backforce;
    vec2 turbulence; // x component is turbulence
};

struct AirGeoMapElement {
    int geoCount;
    int geoIndices[MAX_GEO_PER_AIR];
};

// Constants -------------------------------------------------------------------

const uint k_workGroupSize = gl_WorkGroupSize.x * gl_WorkGroupSize.y * gl_WorkGroupSize.z;
const bool k_debug = DEBUG;
const bool k_distinguishActivePixels = DISTINGUISH_ACTIVE_PIXELS; // Makes certain "active" pixels brigher for visual clarity, but lowers performance
const float k_inactiveVal = k_distinguishActivePixels && k_debug ? 1.0f / 3.0f : 1.0f;
const int k_maxEdgeSeekSteps = 64; // Necessary in pathological cases where normals form a loop
const float k_minNormalZ = 1.0f / 1000000.0f;
const float k_maxNormalZ = 1.0f - k_minNormalZ;

// Uniforms --------------------------------------------------------------------

layout (binding = 0,        rgba8) uniform  image2D u_fboImg;
layout (binding = 1, rgba16_snorm) uniform  image2D u_fboNormImg;
layout (binding = 2,         r32i) uniform iimage2D u_flagImg;

// Uniform buffer for better read-only performance
layout (binding = 0, std140) uniform Constants {
    int u_maxGeoPixels;
    int u_maxAirPixels;
    int u_screenSize;
    float u_liftC;
    float u_dragC;
    float u_windframeSize;
    float u_windframeDepth;
    float u_sliceSize;
    float u_turbulenceDist;
    float u_maxSearchDist;
    float u_windShadDist;
    float u_backforceC;
    float u_flowback;
    float u_initVelC;
    float u_windSpeed;
    float u_dt;
    int u_slice;
    float u_sliceZ;
    float u_pixelSize;
};

layout (binding = 0, std430) restrict buffer GeoPixels {
    int u_geoCount;
    int u_GeoPixels_pad0;
    int u_GeoPixels_pad1;
    int u_GeoPixels_pad2;
    GeoPixel u_geoPixels[];
};

layout (binding = 1, std430) restrict buffer AirPixels {
    int u_airCount;
    int u_AirPixels_pad0;
    int u_AirPixels_pad1;
    int u_AirPixels_pad2;
    AirPixel u_airPixels[];
};

layout (binding = 2, std430) restrict buffer PrevAirPixels {
    int u_prevAirCount;
    int u_PrevAirPixels_pad0;
    int u_PrevAirPixels_pad1;
    int u_PrevAirPixels_pad2;
    AirPixel u_prevAirPixels[];
};

layout (binding = 3, std430) restrict buffer AirGeoMap {
    AirGeoMapElement u_airGeoMap[];
};

layout (binding = 4, std430) restrict buffer Results {
    Result u_results[];
};

// Functions -------------------------------------------------------------------

vec2 windToScreen(vec2 wind) {
    return (wind / u_windframeSize + 0.5f) * float(u_screenSize);
}

vec2 screenToWind(vec2 screen) {
    return (screen / u_screenSize - 0.5f) * u_windframeSize;
}

// Returns one of <1, 0>, <-1, 0>, <0, 1>, <0, -1> corresponding to dir
ivec2 getPixelDelta(vec2 dir) {
    vec2 signs = sign(dir);
    vec2 mags = dir * signs;
    if (mags.y >= mags.x) {
        return ivec2(0, int(signs.y));
    }
    else {
        return ivec2(int(signs.x), 0);
    }
}

void doOne(int prevAirI) {
    AirPixel air = u_prevAirPixels[prevAirI];
    ivec2 airTexCoord = ivec2(windToScreen(air.windPos));

    // Check if in texture
    if (airTexCoord.x < 0 || airTexCoord.y < 0 || airTexCoord.x >= u_screenSize || airTexCoord.y >= u_screenSize) {
        return;
    }

    vec4 color = imageLoad(u_fboImg, airTexCoord);

    // If in geometry, follow the geo normals to find the edge
    if (color.r != 0.0f) {
        ivec2 pixel = airTexCoord;
        int steps = 0;
        while (true) {
            vec3 geoNormal = imageLoad(u_fboNormImg, airTexCoord).xyz;
            if (abs(geoNormal.z) > k_maxNormalZ) {
                return;
            }
            ivec2 nextPixel = pixel + getPixelDelta(geoNormal.xy);
            vec4 nextColor = imageLoad(u_fboImg, nextPixel);

            // We found the edge, move air to it
            if (nextColor.r == 0.0f) {
                airTexCoord = pixel;

                //vec3 tangentVel = cross(geoNormal, cross(geoNormal, vec3(0.0f, 0.0f, 1.0f))); // TODO
                //vec2 tangentVel = geoNormal.xy * geoNormal.z; // Equivalent to above
                //tangentVel = tangentVel * u_windSpeed;

                vec2 norm = normalize(geoNormal.xy);
                if (geoNormal.z > 0.0f) {
                    air.velocity = max(dot(air.velocity, norm), geoNormal.z * u_windSpeed) * norm;
                }
                else {
                    air.velocity = geoNormal.z * u_windSpeed * norm;
                }

                air.backforce = vec2(0.0f);
                air.turbulence = vec2(0.0f);
                break;
            }

            // If air "inside" geometry, get rid of it, unless it's on the very edge
            if (geoNormal.z < 0.0f) {
                return;
            }

            // TODO: position here instead
            air.windPos = vec2(0.0f); // Signify to outline shader that this air has been adjusted and needs properly positioned

            pixel = nextPixel;
            color = nextColor;
            if (++steps >= k_maxEdgeSeekSteps) {
                return;
            }
        }
    }

    // air.windPos now invalid if there was edge seek

    // Air already exists at pixel
    if (color.g != 0.0f) {
        return;
    }

    // Move to current air pixel buffer
    int airI = atomicAdd(u_airCount, 1);
    if (airI >= u_maxAirPixels) {
        return;
    }
    u_airPixels[airI] = air;
    u_airGeoMap[airI].geoCount = 0; // This air pixel is not yet associated with any geometry

    // Store air index
    imageStore(u_flagImg, airTexCoord, ivec4(airI + 1, 0, 0, 0));

    // Draw to front view
    color.g = k_inactiveVal;
    imageStore(u_fboImg, airTexCoord, color);
}

void main() {
    int workI = int(gl_LocalInvocationIndex);
    for (int prevAirI = workI; prevAirI < u_prevAirCount; prevAirI += int(k_workGroupSize)) {
        doOne(prevAirI);
    }
}
